%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% StuPro A, Produktlinien (Kobold)
%% Team Werkbold
%% Angebot
%% $Id: anforderungen.tex,v 1.1 2004/01/28 18:10:49 garbeam Exp $
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\section{Anforderungen}

%\section{Problemstellung}
%
%Es soll ein Softwaresystem entwickelt werden, welches die Umsetzung von-, und 
%die Einhaltung der für die Entwicklung geltenden Regeln des Produktliniengedankens 
%unterstützt.  In diesem Falle sind dies Architektur Richtlinien, Zugriffsbeschränkungen 
%und Arbeitsabläufe.  Um ein generelles Verständnis des Problems zu erhalten, ist 
%es nötig sich mit dem Produktliniengedanken auseinander zusetzen.  Daher werde ich 
%im nächsten Abschnitt auf den Produktlinien Gedanken eingehen, insoweit er für 
%dieses System relevant ist.  Für den interessierten Leser ist in der angegebenen 
%Literatur detailliertere Information erhältlich.

%\subsection{Der Produktlinien Gedanken (the product line practice)}

%Generell versteht man unter Produktlinien eine Palette von Produkten, die sich dadurch 
%auszeichnen, dass die einzelnen Produkte einer Produktlinie sich untereinander durch 
%weniger Merkmale unterscheiden, als dass sie Merkmale gemein hätten.  
%Im Software technischen Sinne, wie auch im Ingenieur technischen Sinne liegt einer 
%Produktlinie immer eine Architektur zu Grunde die es gestattet, verschiedene 
%Kernkomponenten mit möglichst geringem technischen Aufwand so miteinander zu kombinieren, 
%dass ein möglichst individuelles/spezielles, für den end Gebrauch charakteristisches 
%Produkt entsteht.

%\subsection{Problemstellung Fortsetzung}

\section{Problemstellung}
Gefordert ist also ein Werkzeug, das es möglich macht eine Architektur für
eine Produktlinie zu entwerfen, die für alle an der Entwicklung beteiligten
Stellen bindend ist. Das heißt
im konkreten Falle von Softwareproduktlinien, dass ein Produktlinien-Ingenieur (kurz
PLE) grafisch die Architektur der Produktlinie spezifiziert, indem er
Kernkomponenten (so genannte \emph{Core-Assets}) in Beziehung zueinander setzt und aus
ihnen somit die Basis einer Produktlinie schafft. Diese Core-Assets kann man sich als
abstrakte Module vorstellen, aus deren Instanzen neue Produkte entstehen.
Solche Instanzen weichen von einander ab und sind folglich Varianten, welche von einer
bestimmten Entwicklergruppe, den Core-Asset-Entwicklern betreut werden.
Die Beziehungen zwischen den abstrakten Core-Assets sind stets Abhängigkeiten. Zwischen
den Varianten unterschiedlicher Core-Assets können jedoch auch Beziehungen bestehen, die
eine gemeinsame Verwendung in einem Produkt verbieten.
Diese Beziehungen kann der Benutzer sowohl selbst einfügen, als auch über die
XML-Schnittstelle GXL\footnote{Graph eXchange Language, http://www.gupro.de/GXL/} importieren.

\section{Funktionale Anforderungen}
\product verwirklicht die oben geschilderten Aufgaben.

Im Einzelnen wird dies durch folgende Anforderungen realisiert, die im
Hauptprojekt noch detaillierter spezifiziert werden:

\subsection*{Allgemein}
\subsubsection{Architekturgraph}
Der Architekturgraph stellt die grundlegende Produktlinien-
Architektur graphisch dar. Dabei werden die Core-Assets und deren
konkrete Varianten differenziert als Knoten dargestellt. Die oben 
genannten Beziehungen werden durch Kanten in dem Graph visualisiert und
lassen sich über Filter ein und ausblenden.\par
Die Knoten/Komponenten sind in sich verschachtelt und können bis auf
die Dateiebene geöffnet und angezeigt werden.\par
In der Produktansicht werden nur die in dem Produkt instanziierten Core
Assets und deren Beziehungen untereinander angezeigt. Ausserdem werden 
bestimmte Marker, die an diese Komponenten gebunden sind dargestellt.
So ein Marker besagt z.B., ob ein Produktentwickler diese Komponente
verändern darf, oder ob sie von einer neuen Core-Asset-Version vorbehaltlos
überschrieben werden kann. Diese Marker können von dem Produktlinien-Ingenieur
graphisch hinzugefügt, gelöscht oder bearbeitet
werden.\par
Gleiches gilt auch für die Komponentenbeziehungen.
Dem Benutzer steht es frei, die Komponenten visuell
zu verschieben. Diese Veränderung wird gespeichert, ist jedoch nur für diesen
Benutzer relevant.
Die Anzeige des Graphen basiert auf den Informationen aus den Repositories.
Diese werden beim öffnen der Ansicht einmal erzeugt und nicht laufend
aktualisiert.
Strukturelle Änderungen an der Architektur müssen explizit mit den Repositories
synchronisiert werden.

\subsubsection{Schnittgraph}
Um ein Produkt mit der Produktlinienarchitektur zu vergleichen bietet sich
der Schnittgraph. Er zeigt die Unterschiede beider Graphen an und lässt auch
auf mehrere Produkte anwenden. Sonst sind die Eigenschaften identisch mit dem
Architekturgraphen.

\subsubsection{Erfassung von Metadaten}
Für jede Komponente und jede Beziehung können Metadaten erfasst und gespeichert
werden. Das soll eine gezielte Suche nach Asset-Varianten mit bestimmten
Eigenschaften ermöglichen. Für Core-Assets werden \emph{Titel} und 
\emph{Beschreibung} erfasst. Für Asset-Varianten kommt das Felder 
\emph{Schlagwörter} hinzu, in dem griffig die Einzigartigkeit dieser Variante
beschrieben ist. Produkte erhalten zusätzlich noch eine
\emph{Produktbeschreibung}\par
Nach oben genannten Metadaten kann projektübergreifend gesucht werden. 
Die Ergebnismenge lässt sich ganz oder teilweise in eine Selektion in einem
Produktlinienenarchitekturgraphen umwandeln.

\subsubsection{Konsistenzchecks durchführen} 
Anhand der Marker und der Informationen über die Orte der Repositories lassen sich
Konsistenzchecks durchführen. Wenn z.B. ein Produktentwickler in seinem
Produkt-Repository die lokale Kopie einer Core-Asset-Variante modizifiert, obwohl ihm das
nicht gestattet ist, so erkennt \product das und bietet dem Produktlinien-Ingenieur
verschiedene Workflows zur Lösung des Problems an. Möglich wäre es z.B. die Änderungen
des Produktentwicklers über einen Core-Asset-Entwickler in das Core-Asset-Repository
aufzunehmen. Stattdessen könnte man aber auch die Änderungen des Produktentwicklers
verwerfen.

\subsubsection{Suche nach Metadaten und Produktlinienüberblick}
Aus den Metadaten und den Abhängigkeiten wird ein
Produkt- bzw. Produktlinien-Überblick als
Dokument wahlweise im HTML, RTF oder PDF-Format erzeugt.

\subsection*{Produktlinien-Ingenieur}

\subsubsection{Produktlinie erstellen}
Der Produktlinien-Ingenieur kann jederzeit eine neue Produktlinie anlegen.
Dazu legt legt er seine abstrakte Produktlinienarchitektur in dem leeren
Architekturgraphen fest. Sobald dieser Arbeitsschritt abgeschlossen ist,
    lässt er sich von \product die Produktlinien-Repositories erzeugen.

\subsubsection{Produktlinie bearbeiten}
Die erzeugte Produktlinienarchitektur lässt sich auch nachträglich ergänzen
und verändern. So kann er Core-Assets zu seiner Produktlinie hinzufügen
oder andere als \emph deprecated markieren. Diese dürfen dann in Zukunft
nicht mehr genutzt werden. Das Löschen von verwendeten Core-Assets
ist nicht möglich.


\subsubsection{Produkt erstellen}
Aus einer Selektion von Core-Asset-Varianten lässt sich ein neues Produkt
erzeugen. Dieses kann noch durch weitere produktspezifische Komponenten
ergänzt werden.
Zum Abschluss werden das Produkt-Repository angelegt und das Produkt wird
beim Server registriert.

\subsubsection{Produkt bearbeiten}
Wie bei der Produktlinie kann man auch die Architektur der Produkte ändern. Hier
ist es neben Ergänzungen durch oder dem Austauschen von neuen Core-Asset-Varianten
auch möglich, Komponenten aus der Architektur zu entfernen. Hierbei muss der
Produkt-Ingenieur kosultiert werden.

\subsubsection{Produkt löschen}
Zusammen mit dem Projekt-Ingenieur kann ein Produkt aus der Produktlinie
entfernt werden.

\subsubsection{Produkt-Ingenieur anlegen}

Ein Produkt kann ohne Produkt-Ingenieur nicht gewartet werden, deshalb kann
der PLE über diese Funktion neue Benutzer als Produkt-Ingenieure anlegen.

\subsubsection{Produktlinienüberblick erstellen}
Anhand der Metainformationen der Produktlinie und deren
Produkte kann \product eine strukurierter
Überblick in verschiedenen Formaten als Dokument erzeugt werden.

\subsubsection{Core-Assets verwalten}
Die Verwaltung der Core-Assets unterliegt auch dem Produktlinien-Ingenieur.

Im Allgemeinen werden die Core-Assets von einer Core-Asset-Development-Group 
entwickelt und gewartet. Wenn sich in einem Projekt nun zwingende Änderungen
an einer Core-Asset-Variante ergeben, so hat der Produktlinien-Ingenieur nun die
Möglichkeit, diese Änderungen entweder in diese Core-Asset-Variante unter 
Aufsicht des Core-Asset-Entwicklers einzugliedern, mit dieser Änderung eine neue
Core-Asset-Variante zu erstellen oder die Änderung als Produktspezifisch auf der
Produktlinie auszugliedern. Die dazu notwendige Kommunikation wird durch
\product untersützt.

\subsection*{Produkt-Ingenieur}

\subsubsection{Produkt bearbeiten}
Der Produkt-Ingenieur kann sein Produkt beliebig verändern und erweitern, solange
er die Produktlinienarchitektur nicht verletzt. Er kann das Produkt um 
produktspezifische Komponente erweitern.

\subsubsection{Produkt-Entwickler verwalten}
Das Produkt muss von mindestens einem Produkt-Entwickler entwickelt werden.
Diese kann der Produkt-Ingenieur anlegen und entfernen.

\subsubsection{Produktüberblick erstellen}
Anhand der Metainformationen der Produktlinie und der gewählten Core-Asset-Varianten
lässt sich für das Produkt ein strukurierter Überblick in
verschiedenen Formaten als Dokument erzeugen.

\subsection*{Produkt-Entwickler}

\subsubsection{Produkt-Repository auschecken}
Der Produkt-Entwickler kann mit \product direkt alle Produkt-
Repositories in sein Arbeitsverzeichnis auschecken um dort mit
seiner Arbeit zu beginnen.

\subsubsection{Arbeitsverzeichnis aktualisieren}
Veränderung von anderen Entwicklern lassen sich über diese
Funktion in das Arbeitsverzeichnis einpflegen.

\subsubsection{Arbeitsverzeichnis einchecken}
Eigene Veränderungen werden mit dieser Funktion an die Versionskontrolle übergeben.

\subsection{Funktionen}
Alle im aufgeführten Rollen können außerdem die folgenden Funktionen ausführen:
\begin{itemize}
    \item Workflow anstoßen
    \item Produkt- und Produktlinienarchtitektur einsehen
    \item Repositories ansehen
    \item Schnittgraphen anzeigen
    \item Produktlinie und deren Produkte nach Metainformation durchsuchen
\end{itemize}


%\section{Geschäftsprozesseanalyse}
%
%Da der Anwendungsbereich indem das zu entwickelnde System eingesetzt werden
%soll, sich nicht in bestehende Geschäftsprozesse einbindet, sondern den Prozess
%an sich definiert, ist auf eine detaillierte deskriptive
%Geschäftsprozesseanalyse zu verzichten.  Stattdessen werden verschiedene
%Geschäftsprozesse aus der Theorie präskriptiv dargestellt.  Wie in den
%nachfolgenden Aktivitäts Diagrammen dargestellt, gibt es fünf logisch
%voneinander zu trennende Akteure/Rollen.  Zum ersten die oberste Instanz bei
%Produktlinien, den Produktlinienmanager/Produktlinieningenieur.  Zum zweiten,
%ihm Untergebenen und für ein bestimmtes aus der Produktlinie entwickeltes
%Produkt verantwortlich, der Produktingenieur.  Der Produktingenieur, der mit
%einem Team von Programmierern für den Feinentwurf und die Ausarbeitung eines
%einzelnen Produktes zuständig ist, gilt für sein Team als erste Anlaufstelle
%bei konkreten Fragen die das zu entwickelnde Produkt betreffen.  Weiterhin sind
%noch ein oder mehrere Core assets Development Teams angedacht, die jeweils aus
%einem Core assets Ingenieur und einem ihm unterstellten Team von Core assets
%Programmierern bestehen, welche die der Produktlinie gemeinen, so genannten
%Core assets entwickeln, und warten.\par
%
%Um eine neue Produktlinie zu erstellen, legt der Produktlinieningenieur eine
%Architektur fest, indem er zuerst die zu der Produktlinie gehörenden Core
%assets neu anlegt, oder vorhandene hinzufügt und miteinander in Beziehung
%setzt.  Dies soll grafisch anhand eines Beziehungsgraphen geschehen, indem
%einzelne Core assets durch Kanten miteinander in Beziehung gesetzt werden. Dies
%könnten zum Beispiel die obengenannten Kriterien seien. \par
%Falls Core assets neu entwickelt werden müssen, ergeht ein Auftrag an das Core
%asset Development Team.\par
%Wenn dieses mit der Bearbeitung/Erstellung fertig ist, geht das Core asset
%zurück an den Produktlinien Ingenieur um in die Architektur aufgenommen zu
%werden.\par
%
%Wird entschieden ein neues Produkten zu entwickeln, werden die für das Produkt
%benötigten Core assets ausgegliedert und dem Verantwortlichen Produktingenieur
%übergeben.  Falls in einem Produkt Änderungen vorgenommen werden, die die
%Architektur der Produktlinie verändern würden, werden diese nicht eingepflegt,
%sondern erst dem Produktlinieningenieur zur Abnahme vorgelegt.  Grundsätzlich
%werden produktspezifische Änderungen nur über den Produktlinieningenieur wieder
%zurück in die Produktlinienarchitektur übernommen, lokal werden diese jedoch im
%Repository des Produktingenieurs gespeichert.  Falls Fehler in den
%Kernmodulen/Core assets von einem Produktteam gefunden werden, sieht der
%normale Arbeitsablauf einen Report an das Core asset Development Team, dass den
%Fehler dann behebt, vor.\par
%
%Eine weitere Anforderung des Kunden ist, dass das System das Graphen
%Austauschformat GXL unterstützt.\par
%
%
%
% Ausnahme bildet in diesem Fall das Content Versioning System kurz CVS.  Da es
%beim entwickeln von Software unabdingbar ist eine Versionskontrolle zu
%benutzen, wird an das Programm/System die Anforderungen gestellt, mehrere
%verschiedene CVS Systeme zu unterstützen.\par
%
%\section{Systemumfeld}
%
%\section{Antwortzeit verhalten/Performance}
%
%Das System soll es ermöglichen die Architektur, als Graph repräsentiert, zu visualisieren.  
%Es wurde nicht gefordert den ganzen Grafen, der unter Umständen sehr komplex und 
%groß werden kann auf einmal performant zu visualisieren.  Es genügt die für die 
%jeweilige Architekturansicht relevanten Teile des Grafen zu visualisieren.  
%Diese Ausschnitte werden sich der Übersichtlichkeit halber wahrscheinlich in einer 
%Größenordnung zwischen 0 und 125 Knoten bewegen.  Die Anzeige der Teilegrafen sollte 
%die Grenze von 20 Sekunden zur Berechnung der Darstellung nicht überschreiten.
%>>>>>>> 1.9

\section{Nichtfunktionale Anforderungen}

\subsection{Leistungsanforderungen}
Das System wird zunächst so ausgelegt, dass mind. 50 Benutzer gleichzeitig mit dem Produkt arbeiten können.
Die Skalierbarkeit hängt ausschliesslich von dem Server ab, dessen Leistungsfähigkeit von der Hardware und
der verwendeten Persistenzschicht-Implementierung beeinflusst wird. Garantiert wird die Bereitstellung von 
10 Produktlinien zu je 50 Produkten. Pro Produktlinie können 100 Benutzer verwaltet werden.

\subsection{Minimale Hardwareanforderungen}
Das Softwaresystem wird auf einem Pentium II basierten PC mit 400 Mhz CPU-Takt, 256 MB Hauptspeicher
und mind. 200 MB freien Festplattenspeicher (oder unter einer vergleichbaren Unix-Workstation)
unter den Betriebssystemen Windows, Solaris und Linux lauffähig sein.

\subsection{Entwurfseinschränkungen}
Das Produkt wird in Java 2 Version 1.4 implementiert. Als Workbench-Framework wird die 
Eclipse Plattform\footnote{http://www.eclipse.org/, http://www.eclipse.org/platform/}
verwendet, sowie deren Widgettoolkit SWT\footnote{Standard Widget Toolkit, http://www.eclipse.org/swt/}
und GEF\footnote{Graphical Editing Framework, http://www.eclipse.org/gef/}.
Zudem werden Bibliotheken von der Apache Software
Foundation\footnote{http://www.apache.org/} benutzt. Die
Generierung der Dokumenation setzt auf iText\footnote{http://www.lowagie.com/iText/} auf.

\subsection{Verfügbarkeit}
Für den Client gibt es keine besonderen Anforderungen bzgl. der Verfügbarkeit. Die Verfügbarkeit des Servers
hängt maßgeblich von der Konfiguration des Rechners ab, der den Serverdienst zur Vefügung stellt.

\subsection{Sicherheit}
Die Daten, die der Server bereitstellt, werden bei jeder Änderung sofort auf dem Datenträger gespeichert.
Somit wird die Gefahr eines Datenverlusts beim Eintritt von unvorhersehbaren Ereignissen minimiert.
Alle Client-spezifischen Daten werden in den Produktlinien- bzw.
Produkt-Repositories gespeichert und unterliegen  den Sicherheitsregeln des verwendeten
Versionskontrollsystems.

\subsection{Robustheit}
Fehleingaben und Fehler im System werden erkannt und dem Benutzer mit einer aussagekräftigen 
Fehlermeldung mitgeteilt.
Sie führen nicht zum Programmabsturz.

\subsection{Wartbarkeit}
Durch die ständige Überprüfung des Programmquellcodes mit Metriken auf Kopplung, Zusammenhalt und
Styleguide-Konformität wird die hohe Wartbarkeit des 
Produkts gewährleistet. Zudem wird das Produkt mit einer umfangreichen
Regression-Testsuite für die Nicht-GUI-Komponenten ausgeliefert.

\subsection{Performance}
%Das Softwaresystem soll laut Kundenangaben auf einem handelsüblichen
%Pentium II PC mit mind. 400 Mhz CPU-Takt, mind. 256 MB Hauptspeicher
%und 200 MB freien Festplattenspeicher (oder auf einer vergleichbare Unix-Workstation)
%unter den Betriebssystemen Windows, Solaris oder Linux lauffähig sein.
%Das System soll es ermöglichen die Produkt(-linien) Architekturen als Graph zu
%visualisieren.
%Es wurde nicht gefordert den ganzen Graphen, der unter Umständen sehr komplex und 
%groß werden kann, auf einmal performant zu visualisieren.\par
%Es genügt die für die 
%jeweilige Architekturansicht relevanten Teile des Graphen zu visualisieren.
%Diese Ausschnitte werden sich der Übersichtlichkeit halber wahrscheinlich in einer 
%Größenordnung bis zu 125 Knoten bewegen. Die Anzeige der Teilgraphen sollte 
%eine Grenze von 8 Sekunden zur Berechnung der Darstellung nicht überschreiten.
Es wurde nicht gefordert den ganzen Graphen, der unter Umständen sehr komplex
werden kann, performant zu visualisieren.\par
Es soll genügen, die für die jeweilige Architekturansicht relevanten
Ausschnitte des Graphen zu visualisieren.
Diese werden sich der Übersichtlichkeit proforma in einer 
Größenordnung bis zu 125 Knoten bewegen. Die Anzeige der Teilgraphen sollte 
eine Grenze von 8 Sekunden zur Berechnung der Darstellung nicht überschreiten.

\subsection{Portabilität}
Der Server stützt sich auf keine nativen Schnittstellen sondern benutzt ausschließlich 
\emph{pure java}. Somit ist er laut Sun Microsystems 
Inc.\footnote{unter http://java.sun.com/j2se/1.4.2/system-configurations.html} unter 
Solaris-SPARC, Solaris-Intel, Windows NT/2000/XP und Linux lauffähig.

Der Client basiert grundlegend auf der Eclipse Plattform und deren Widgettoolkit und ist
dadurch von dessen nativer Schnittstelle abhängig. Laut dem Eclipse Consortium werden die folgenden 
Plattformen und Betriebssysteme unterstützt:
\begin{itemize}
    \item Windows NT/2000/XP
    \item Linux (x86/Motif)
    \item Linux (x86/GTK 2)
    \item Solaris 8 (SPARC/Motif)
    \item QNX (x86/Photon)
    \item AIX (PPC/Motif) 
    \item HP-UX (HP9000/Motif)
    \item Mac OSX (Mac/Carbon)
\end{itemize}


%%% Local Variables: 
%%% TeX-master: "angebot"
%%% End: 
%%% vim:tw=79:
