\chapter{Client}
Der Client wird nach dem Model-View-Controller Design Pattern als
Feature-Set für Eclipse entwickelt. Dank der verwendeten Framework-SDKs
(Eclipse SDK, Draw2D, GEF) lassen sich die Module in das MVC Design
Pattern leicht integrieren.

\section{Überblick}
\includegraphics[width=15cm]{client.jpg}

\subsection{MVC-Aufteilung}
Idee des Model-View-Controller Design Patterns ist die Entkopplung der Komponenten
in Gruppen, die ausschließlich der Darstellung (View) bzw. Datenhaltung 
(Model) dienen. Die Vermittlung zwischen beiden Gruppen übernehmen Controller,
so dass die Views und Models keine direkten Abhängigkeiten haben.

Für die Darstellung und Bearbeitung der Architektur ist es notwendig auch 
view-spezifische Informationen für den Benutzer zu speichern (z.B. Position 
der Architektur-Elemente), so dass hier ein View-Model zum Einsatz kommt, 
welches das eigentliche Architektur-Model erweitert.\par

Die Aufteilung der Client-Komponenten in MVC-Gruppen sieht wie folgt aus:\par

{\bf View}
\begin{itemize}
    \item Komponente RollenView
    \item Komponente ArchitekturEditor
    \item Komponente Minimap
    \item Komponente Task-/WorkflowView
    \item Komponente TaskDetailView
\end{itemize}\par

{\bf Model}
\begin{itemize}
    \item Komponente ArchitekturModel
    \item Komponente ArchitekturViewModel
    \item Komponente GXL
    \item Komponente MessageQueue
\end{itemize}\par

{\bf Controller}
\begin{itemize}
    \item Delegator-Komponente Server-Kommunikation
    \item Komponente VCM-Wrapper
    \item Komponente GEF (teilweise 3rd-Party)
    \item Komponente Eclipse-Plattform (teilweise 3rd-Party)
    \item Komponente Team-Plugin (teilweise 3rd-Party)
\end{itemize}\par

\section{Viewkomponente RollenView}
Die Rollenview zeigt in einem Baum die Rollen und dazugehörigen
Produkte bzw. die zugehörige Produktlinie des angemeldeten Benutzers an
(siehe auch 2.1.1. und 2.2.4., Spezifikation I).\par

Die Rollenview operiert über die Eclipse-Plattform (ITreeContentProvider) auf der
Komponente ArchitekturModel.

Die Rollenview kann Aktionen in der Komponente VCM-Wrapper auslösen sowie
den Architektur-Editor steuern.

\section{Viewkomponente ArchitekturEditor}
Der Architektur-Editor wird mittels der Draw2D und GEF Frameworks realisiert
und stellt die Produktlinienarchitektur gemäß 2.2.2., Spezifikation I
dar.  Er operiert via GEF auf dem ArchitekturViewModel.
Auch die Viewkomponente kann Aktionen des VCM-Wrappers ausführen.

\section{Viewkomponente Minimap}
Die Minimap (2.2.3., Spezifikation I) ist direkt mit dem Architektur-Editor 
verknüpft und stellt eine verkleinerte Fassung der Architektur dar.

\section{Viewkomponente Task-/WorkflowView}
Diese Komponente zeigt die Tasks und Workflows an. Sie operiert über die
Controllerkomponente Eclipse-Plattform (IMarker) auf der Komponente MessageQueue.

\section{Viewkomponente TaskDetailView}
Hier werden die Details zu einem Workflow angezeigt. Die Daten werden über die
MessageQueue bezogen.

\section{Modelkomponente ArchitekturModel}
Das Architektur-Model enthält baumartig aufgebaut alle Informationen über die
Produktlinie(n). Das umfasst Varianten, Komponenten, Assets und Benutzer.

\section{Modelkomponente ArchitekturViewModel}
Diese Komponente repräsentiert auf Modelebene all das, was im Architektur-
Editor angezeigt wird. Das Viewmodel enthält zusätzlich noch Informationen 
über die Position der einzelnen Viewelemente auf dem Canvas. Der Aufbau der
ViewModel-Elemente erfolgt dynamisch auf Basis des Architektur-Models und 
durchläuft Filter, die steuern, welche Elemente tatsächlich angezeigt werden 
sollen. Somit wird eine performantere Darstellung gesichert.

\section{Modelkomponente GXL}
Import und Export der Architekturmodels von und nach GXL.

\section{Modelkomponente MessageQueue}
Diese Komponente ist die lokale Repräsentation der MessageQueue auf dem Server.
Alle Nachrichten werden über die Server-Kommunikations-Komponente bezogen und 
lokal gespeichert. Diese Komponente bedient über den Eclipse-Controller die
Task-/Workflow-Viewkomponente.

\section{Controllerkomponente Server-Kommunikation}
Diese Singleton-Komponente übernimmt die Kommunikation mit dem Kobold Server.
Die Kommunikation findet mittels HTTPS (SSL) basierter XML-RPCs statt. Das
von der Komponente implementierte Querschnitts-Interface ist unter Kapitel
\ref{cha_interface} näher erläutert.

Neben der Delegierung der Methodenaufrufe an den Server
via XML-RPC kapselt die Komponente auch das Berechtigungskonzept
zum Server von den restlichen clientseitigen Komponenten ab.

\subsection{Kapselung des Berechtigungskonzeptes}

Die Controllerkomponente Server-Kommunikation meldet sich mit
Benutzernamen und Passwort am Kobold Server an und erhält vom
Server eine spezifische Session-ID. Danach werden vom
Server alle Konfigurationsdaten geladen und automatisch mit der
vorhandenen Konfiguration der Eclipse Entwicklungsumgebung abgeglichen.

Beim ersten Login am Server wird von diesem eine eindeutige Session-ID
vergeben, die bei erneutem Zugriff auf den Server zur Authentifizierung
genutzt wird. 

Falls die selben Benutzerdaten von verschiedenen Clients zur
Authentifizierung am Server verwendet werden, wird die erste bereits
vergebene Session-ID ungültig und eine neue Session-ID an die zweite
Client Instanz vergeben. Dadurch wird die Datenkonsistenz
sichergestellt.

\subsection{Resultatwerte der XML-RPC Aufrufe}

Durch die Auswertung der Resultatwerte von XML-RPCs kann die
Komponente entscheiden, ob die Server-Aktion erfolgreich
ausgeführt wurde oder ob eine erneute Authentifizierung notwendig ist.

\section{Controllerkomponente GEF}
Das Graphical Editing Framework ist ein MVC-basiertes Editing-Framework von 
Eclipse. Der Architektur-Editor setzt darauf auf und kommuniziert über darüber
mit dem ArchitekturViewModel.

\section{Controllerkomponente Eclipse-Plattform}
Die Eclipse-Plattform bietet viele MVC-unterstützende Klassen und Komponenten
mit deren Hilfe die Trennung zwischen Model und View ermöglicht wird.

\section{Controllerkomponente Team-Plugin}
Die Teamplugins sind die Team-Komponenten an die der VCM-Wrapper die Anfragen
weiterdelegiert. In der Eclipse-Plattform ist das CVS-Team-Plugin bereits 
enthalten. Weitere Plugins sind als 3rd-Party-Module verfügbar.

\section{Controlerkomponente VCM-Wrapper}

Der VCM-Wrapper spiegelt der Eclipse-Plattform ein vollfunktionsfähiges Team-
Plugin vor, über das alle Repositoryoperationen durchgeführt werden. Intern
delegiert die Komponente die Aktionen jedoch an die eigentlichen
(3rd-Party) Team-Plugins weiter.

Vor jeder dieser Aktion wird die Kommunikations-Komponente
konsultiert, um die Berechtigung der Aktion zu validieren. Sollte keine
Berechtigung aus Sicht der Kobold Rollenkonfiguration vorhanden sein,
kann der Benutzer die Aktion abbrechen bzw. die Aktion forcen. Sollte
die Aktion geforced werden, wird in jedem Fall ein Workflow nach
erfolgter Aktionsausführung an den Server über die
Kommunikations-Komponente beauftragt.

Die VCM-Wrapper-Komponente hat sowohl auf Metainformationen der Datei-Ebene
und deren Repositories als auch auf die Abstraktion auf
Produktlinien/Komponenten/Varianten durch Serveraufrufe Zugriff und kann
dadurch Konsistenzprüfungen der Metainformationen durchführen.

Darüber hinaus kapselt der VCM-Wrapper die Importierung von
produktlinien- bzw. produktspezifischen Repository-Konfigurationen in
die Eclipse-Plattform (Repository Perspektive) ab. Hierdurch wird eine
optimale Anbindung an bereits existierende Eclipse-Strukturen
geschaffen.

\subsection{Ablaufschritte beim Zugriff auf Repositories durch den VCM-Wrapper}

Die Ablaufschritte:\par

\begin{itemize}
    \item Lade Konfigurationsdaten vom Server (fetch)
    \item Extrahiere Repository-Daten (Server, Repository-Pfad, Repository-Username,
            Repository-Passwort) (extract)
    \item Lokale Prüfung auf vorhandene Produkt-Arbeitskopie (check)
    \item Prüfungsergebnisse führen bei nicht vorhandenem Produkt zu
    öffnendem Dialog und anschließender Intial-Lade-Aktion aus dem
    Repository (checkout)
\end{itemize}\par

\subsection{Mögliche Wrapper-Aktionen}

Alle möglichen Wrapper-Aktionen lassen sich in zwei verschiedene
Gruppen einteilen. Aktionen die keine Berechtigung erfordern, d.h. für
alle Benutzer möglich sind und Aktionen die eine Berechtigung
erfordern, d.h. nur für bestimmte Benutzer möglich sind.\par

Die sichtbaren Aktionen:\par

{\bf Alle Benutzer:}
\begin{itemize}
  \item check out: Vorbedingung: Lese-Zugriff auf Repository
  \item update: Vorbedingung: check out
\end{itemize}
Bspw. ist es für Programmierer möglich Core-Assets aus dem
Produktlinien-Repository auszuchecken, sofern sie Lese-Berechtigung auf
das PL-Repository haben. I.d.R. wird dies der Fall und im Interesse der
PL-Beteiligten sein.

{\bf Nur bestimmte Benutzer:}

\begin{itemize}
  \item import: Vorbedingung: Schreib-Berechtigung
  \item commit: Vorbedingung: check out und Schreib-Berechtigung
  \item delete: -
  \item add: -
\end{itemize}
Bspw. gehören PLEs oder PEs zur Gruppe bestimmter Benutzer, die
Schreibrechte auf der Ebene der PL oder eines Produktes haben.
Schreib-Rechte implizieren Leserechte.

Falls eine Aktion der zweiten Gruppe nicht erfolgreich ausgeführt
werden kann, entweder weil der Client feststellt dass der Benutzer
nicht die passende Rolle und Berechtigung besitzt, d.h. eine unerlaubte
Aktion angestoßen wurde oder weil der Repository-Server beim Durchführen der
Aktion eine Fehlermeldung zurück gibt, wird über die
Server-Kommunikations Schnittstelle auf dem Server ein Workflow mit
Aktionskontext beauftragt.

\subsection{Skriptausführung}

Vor und nach VCM-Aktionen wie checkout, import, update und commit können
auf Datei oder Verzeichnisebene beliebige Skripte (externe
Prozessaufrufe) in frei definierbarer Reihenfolge sequentiell ausgeführt
werden (z.B. zur Substitution bestimmter Dateiinhalte).

\subsection{Der initiale Metadaten-Abgleich}

Als Metadaten sind alle datei- und verzeichnisbezogenen
Repository-Metadaten wie Revision, letzter Bearbeiter, Datum der letzten
Änderung, etc. gemeint.

Bei der initialen Erstellung von Produklinien oder Produkten mit
vorhandenen Sourcen wird durch den VCM-Wrapper ein initialer
Metadaten-Abgleich realisiert. Dieser liefert eine initiale Menge aller
Metainformationen der dem Produkt oder der Produktlinie zugeordneten
Meta-Informationen.

\subsection{Der allgemeine Metadaten-Abgleich}

Nach allen Schreibaktionen auf ein Produkt-Repository oder
Produktlinien-Repository müssen die zugehörigen Meta-Informationen
abgeglichen werden. Um die Metadaten aktuell zu halten, müssen zuerst
alle produkt- bzw. produktlinienspezifischen Daten committed werden,
danach die Metadaten abgeglichen werden und schlussendlich die
Metainformationsdateien selbst, über die kein Meta-Informationsabgleich
durchgeführt wird, committed werden. Dies wird durch folgende
Reihenfolge beim Schreiben von Metainformationen verdeutlicht:

\begin{itemize}
  \item commit aller Dateien (Änderungen), damit werden die aktuellen (neuen)
  Revisionsnummern gesetzt
  \item commit der Metadaten (neue Revisionen)
\end{itemize}


\subsection{Konsistenzcheck der Metadaten}

Zur Prüfung der aufgezeichneten Metadaten bietet der VCM-Wrapper einen
Delta-Algorithmus zum Vergleich gegebener Metadaten mit den
tatsächlichen Repository-Metadaten an. Dieser erhält als Eingabe die
gegebenen Metadaten und liefert als Rückgabe ein Delta.

\subsection{Einschränkungen bei der Implementierung}
\begin{itemize}
  \item ``eigene'' Eclipse VCM-Aktionen müssen abgefangen
  werden. Ansonsten können Daten ungesehen manipuliert
  werden. Ggf. erlauben, aber dann den Benutzer auf die Folgen
  hinweisen.
  \item ``eigene'' eclipse VCM-Aktionen sind nur über ``Extension
  Points'' aufrufbar, daher muss im ``red book'' nach guten
  Code-Schnittstellen geschaut werden.
  \item
\end{itemize}

\subsection{Entwurfsdetails}

Der VCM-Wrapper wird als Repository Provider {\it
WrappedVCMProvider} für die Eclipse Team
Komponente realisiert und erbt demzufolge von der abstrakten Klasse:
\begin{verbatim}
org.eclipse.team.core.RepositoryProvider
\end{verbatim}\footnote{http://help.eclipse.org/help21/index.jsp}

Er stellt demnach ein eigenständiges Team Plugin dar mit
Kobold-spezifischen Erweiterungen. In der zugehörigen {\it plugin.xml}
des VCM-Wrapper Plugins wird die folgende Repository Extension Point
Definition verwendet:

\begin{verbatim}
<extension point="org.eclipse.team.core.repository">
  <repository class="kobold.client.controller.WrappedVCMProvider"
      id="kobold.client.controller.WrappedVCMProviderID"/>
</extension>
\end{verbatim}
