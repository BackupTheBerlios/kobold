\chapter{Client}
Der Client wird nach dem Model-View-Controller Design Pattern als
Feature-Set für Eclipse entwickelt. Dank der verwendeten Framework-SDKs
(Eclipse SDK, Draw2D, GEF) lassen sich die Module in das MVC Design
Pattern leicht integrieren.

\section{Überblick}
\includegraphics[width=15cm]{client.jpg}

\subsection{MVC-Aufteilung}
Idee des Model-View-Controller Design Patterns ist die Entkopplung der Komponenten
in Gruppen, die ausschließlich der Darstellung (View) bzw. Datenhaltung 
(Model) dienen. Die Vermittlung zwischen beiden Gruppen übernehmen Controller,
so dass die Views und Models keine direkten Abhängigkeiten haben.

Für die Darstellung und Bearbeitung der Architektur ist es notwendig auch 
view-spezifische Informationen für den Benutzer zu speichern (z.B. Position 
der Architektur-Elemente), so dass hier ein View-Model zum Einsatz kommt, 
welches das eigentliche Architektur-Model erweitert.\par

Die Aufteilung der Client-Komponenten in MVC-Gruppen sieht wie folgt aus:\par

{\bf View}
\begin{itemize}
    \item Komponente RollenView
    \item Komponente ArchitekturEditor
    \item Komponente Minimap
    \item Komponente Task-/WorkflowView
    \item Komponente TaskDetailView
\end{itemize}\par

{\bf Model}
\begin{itemize}
    \item Komponente ArchitekturModel
    \item Komponente ArchitekturViewModel
    \item Komponente GXL
    \item Komponente MessageQueue
\end{itemize}\par

{\bf Controller}
\begin{itemize}
    \item Delegator-Komponente Server-Kommunikation
    \item Komponente VCM-Wrapper
    \item Komponente GEF (teilweise 3rd-Party)
    \item Komponente Eclipse-Plattform (teilweise 3rd-Party)
    \item Komponente Team-Plugin (teilweise 3rd-Party)
\end{itemize}\par

\section{Viewkomponente RollenView}
Die Rollenview zeigt in einem Baum die Rollen und dazugehörigen
Produkte bzw. die zugehörige Produktlinie des angemeldeten Benutzers an
(siehe auch 2.1.1. und 2.2.4., Spezifikation I).\par

Die Rollenview operiert über die Eclipse-Plattform (ITreeContentProvider) auf der
Komponente ArchitekturModel.

Die Rollenview kann Aktionen in der Komponente VCM-Wrapper auslösen sowie
den Architektur-Editor steuern.

\section{Viewkomponente ArchitekturEditor}
Der Architektur-Editor wird mittels der Draw2D und GEF Frameworks realisiert
und stellt die Produktlinienarchitektur gemäß 2.2.2., Spezifikation I
dar.  Er operiert via GEF auf dem ArchitekturViewModel.
Auch die Viewkomponente kann Aktionen des VCM-Wrappers ausführen.

\section{Viewkomponente Minimap}
Die Minimap (2.2.3., Spezifikation I) ist direkt mit dem Architektur-Editor 
verknüpft und stellt eine verkleinerte Fassung der Architektur dar.

\section{Viewkomponente Task-/WorkflowView}
Diese Komponente zeigt die Tasks und Workflows an. Sie operiert über die
Controllerkomponente Eclipse-Plattform (IMarker) auf der Komponente MessageQueue.

\section{Viewkomponente TaskDetailView}
Hier werden die Details zu einem Workflow angezeigt. Die Daten werden über die
MessageQueue bezogen.

\section{Modelkomponente ArchitekturModel}
Das Architektur-Model enthält baumartig aufgebaut alle Informationen über die
Produktlinie(n). Das umfasst Varianten, Komponenten, Assets und Benutzer.

\section{Modelkomponente ArchitekturViewModel}
Diese Komponente repräsentiert auf Modelebene all das, was im Architektur-
Editor angezeigt wird. Das Viewmodel enthält zusätzlich noch Informationen 
über die Position der einzelnen Viewelemente auf dem Canvas. Der Aufbau der
ViewModel-Elemente erfolgt dynamisch auf Basis des Architektur-Models und 
durchläuft Filter, die steuern, welche Elemente tatsächlich angezeigt werden 
sollen. Somit wird eine performantere Darstellung gesichert.

\section{Modelkomponente GXL}
Import und Export der Architekturmodels von und nach GXL.

\section{Modelkomponente MessageQueue}
Diese Komponente ist die lokale Repräsentation der MessageQueue auf dem Server.
Alle Nachrichten werden über die Server-Kommunikations-Komponente bezogen und 
lokal gespeichert. Diese Komponente bedient über den Eclipse-Controller die
Task-/Workflow-Viewkomponente.

\section{Controllerkomponente Server-Kommunikation}
Diese Singleton-Komponente übernimmt die Kommunikation mit dem Kobold Server.
Die Kommunikation findet mittels HTTPS (SSL) basierter XML-RPCs statt. Das
von der Komponente implementierte Querschnitts-Interface ist unter Kapitel
\ref{cha_interface} näher erläutert.

Neben der Delegierung der Methodenaufrufe an den Server
via XML-RPC kapselt die Komponente auch das Berechtigungskonzept
zum Server von den restlichen clientseitigen Komponenten ab.

\subsection{Kapselung des Berechtigungskonzeptes}

Die Controllerkomponente Server-Kommunikation meldet sich mit
Benutzernamen und Passwort am Kobold Server an und erhält vom
Server eine spezifische Session-ID. Danach werden vom
Server alle Konfigurationsdaten geladen und automatisch mit der
vorhandenen Konfiguration der Eclipse Entwicklungsumgebung abgeglichen.

Beim ersten Login am Server wird von diesem eine eindeutige Session-ID
vergeben, die bei erneutem Zugriff auf den Server zur Authentifizierung
genutzt wird. 

Falls die selben Benutzerdaten von verschiedenen Clients zur
Authentifizierung am Server verwendet werden, wird die erste bereits
vergebene Session-ID ungültig und eine neue Session-ID an die zweite
Client Instanz vergeben. Dadurch wird die Datenkonsistenz
sichergestellt.

\subsection{Resultatwerte der XML-RPC Aufrufe}

Durch die Auswertung der Resultatwerte von XML-RPCs kann die
Komponente entscheiden, ob die Server-Aktion erfolgreich
ausgeführt wurde oder ob eine erneute Authentifizierung notwendig ist.

\section{Controllerkomponente GEF}
Das Graphical Editing Framework ist ein MVC-basiertes Editing-Framework von 
Eclipse. Der Architektur-Editor setzt darauf auf und kommuniziert über darüber
mit dem ArchitekturViewModel.

\section{Controllerkomponente Eclipse-Plattform}
Die Eclipse-Plattform bietet viele MVC-unterstützende Klassen und Komponenten
mit deren Hilfe die Trennung zwischen Model und View ermöglicht wird.

\section{Controllerkomponente Team-Plugin}
Die Teamplugins sind die Team-Komponenten an die der VCM-Wrapper die Anfragen
weiterdelegiert. In der Eclipse-Plattform ist das CVS-Team-Plugin bereits 
enthalten. Weitere Plugins sind als 3rd-Party-Module verfügbar.

\section{Controlerkomponente VCM-Wrapper}
\subsection{Zusammenfassung}
Der VCM-Wrapper spiegelt der Eclipse-Plattform ein vollfunktionsfähiges Team-
Plugin vor, über das alle Repositoryoperationen durchgeführt werden. Intern
gibt die Komponente die Aktionen jedoch an andere Team-Plugins weiter. Vor und
nach jeder dieser Aktion wird die Kommunikations-Komponente konsultiert, um 
den Server bzw. andere Clients über Veränderungen am Repository zu 
informieren. Die VCM-Wrapper-Komponente kennt sowohl die Datei-Ebene und deren
Repositories als auch die Abstraktion auf Produktlinien/Komponenten/Varianten.
Für beide Ebenen lassen sich atomare (z.B. checkin) und komplexe VCM-
Aktionen () ausführen. Die nötigen Informationen über 
Repository-Positionen und Struktur bezieht der VCM-Wrapper über die Server-
Kommunikations-Komponente sowie das Architekturmodel.

%\includegraphics[width=15cm]{client.jpg}

\subsection{Manueller Import der Einstellungen}
Der Client stöß die Delegater-Schicht an. Als positives Ergebnis sind
alle Konfigurationsdaten in Eclipse gespeichert. 
\par 
Durch diese Konfigurationsdaten kann Eclipse entscheiden welche
Repositories, zugehörige Rollen und Zugriffsrechte benutzt werden
müssen.
Dadurch können in Eclipse durch die erhaltenen Rollen und
Repository-Daten die vordefinierten Felder zum Zugriff auf
VCM-Repositories entsprechend gesetzt werden. Hierdurch wird eine
optimale Anbindung an bereits existierende Eclipse-Strukturen
geschaffen. 

\subsection{Automatischer Import der Einstellungen}
Falls der Benutzer das erste Mal Eclipse startet, d.h. noch keine
Konfigurationsdaten zu Rollen und Repositories vorliegen, wird die
delegater-Schicht automatisch angestoßen, und die Konfigurationsdaten
vom Server geladen und in Eclipsae gepeichert, wie im manuellen
Import näher beschrieben.

\subsection{Ablaufschritte beim Zugriff auf das Repository}

Die Ablaufschritte:\par

\begin{itemize}
    \item Lade Konfigurationsdaten vom Server (fetch)
    \item Extrahiere Rollenzuteilung, Repository-Daten
    \item Lokale Prüfung auf vorhandenes Produkt, d.h. Produktdaten, Benutzerdaten (check)
    \item Prüfungsergebnisse führen bei nicht vorhandenem Produkt zu
    öffnendem Dialog und anschließender Lade-Aktion (checkout) aus dem
    Repository
\end{itemize}\par

\subsection{Mögliche Wrapper-Aktionen}

Alle möglichen Wrapper-Aktionen lassen sich in zwei verschiedene
Gruppen einteilen. Aktionen die keine Berechtigung erfordern, d.h. für
alle Benutzer möglich sind und Aktionen die eine Berechtigung
erfordern, d.h. nur für bestimmte möglich sind.\par

Die sichtbaren Aktionen:\par

{\bf Alle Benutzer:}
\begin{itemize}
  \item check out: immer möglich, ggf. nur Leserechte.
  \item update: Vorbedingung: check out
\end{itemize}

{\bf Nur bestimmte Benutzer:}

\begin{itemize}
  \item commit: Vorbedingung: check out
  \item import: in der ersten Iteration nicht möglich!
  \item delete: -
  \item add: -
\end{itemize}

Falls eine Aktion der zweiten Gruppe nicht erfolgreich ausgeführt
werden kann, entweder weil der Client feststellt dass der Benutzer
nicht die passende Rolle besitzt, d.h. eine unerlaubte Aktion
angestoßen wurde oder weil der Repository-Server beim durchführen der
Aktion eine Fehlermeldung zurück gibt wird auf dem Server ein
passender Workflow der zu dem speziellen Feedback passt, angestossen.


\subsection{Skriptausführung}
Allen möglichen Wrapper-Aktionen kann zusätzlich eine bestimmte
Matainfo-Datei übergeben werden, das eine georndete Liste von Skripten
enthält, die vor und nach einem ``commit'' ausgeführt werden. Diese
möglichen Metainfo-Dateien werden an anderer Stelle festgelegt.

\subsection{Der (initiale) Metadaten-Abgleich}
{\bf Vorbedingung:} Um einen korrekten Konsistenzcheck durchführen zu
können, müssen Informationen über alle Dateien, Verzeichnisse, deren
Autoren und die vorhandenen Dateiversionen vorliegen. Diese werden im
weiteren als Metadaten bezeichnet.\par
Da es passieren kann, dass verschiedene Personen an Dateien und
Versionen arbeiten, sollte vor der produktzusammenstellung eine
erneute Syncronisation dieser Daten durchgeführt werde.

\subsection{Reihenfolge beim Schreiben von Metainformationen}
\begin{itemize}
  \item commit aller Dateien (Änderungen)
  \item update des Repositories, damit werden die aktuellen (neuen)
  Revisionsnummern gesetzt)
  \item commit der Metadaten (neue Revisionen)
\end{itemize}


\subsection{Konsistenzcheck bei der Produktzusammenstellung}
Als Konsistenzcheck wird die Anfrage an die Datenbasis genannt, die
als Eingabeparameter die Revision oder den Autor einer bestimmten
Datei xy erhält und zurückgibt, ob die Datei vorhanden (match=syncron)
ist (oder nicht) und ob die Revision übereinstimmt. Im Fehlerfall wird
ein passender Workflow angestoßen.\par
Zur Überprüfung des gesamten Produktes werden oben genannte Schritte
angewandt, wobei die Eingabemenge aus Dateinamen und deren Revisionen
besteht.


\subsection{Einschränkungen bei der Implementierung}
\begin{itemize}
  \item ``eigene'' Eclipse VCM-Aktionen müssen abgefangen
  werden. Ansonsten können Daten ungesehen manipuliert
  werden. Ggf. erlauben, aber dann den Benutzer auf die Folgen
  hinweisen.
  \item ``eigene'' eclipse VCM-Aktionen sind nur über ``Extension
  Points'' aufrufbar, daher muss im ``red book'' nach guten
  Code-Schnittstellen geschaut werden.
  \item
\end{itemize}
