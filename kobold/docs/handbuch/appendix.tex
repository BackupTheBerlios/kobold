\chapter{Source Code}
\section{IKoboldServer}
\small \begin{verbatim}
/*
 * Copyright (c) 2003 - 2004 Necati Aydin, Armin Cont, 
 * Bettina Druckenmueller, Anselm Garbe, Michael Grosse, 
 * Tammo van Lessen,  Martin Plies, Oliver Rendgen, Patrick Schneider
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense, 
 * and/or sell copies of the Software, and to permit persons to whom the 
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in 
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
 * DEALINGS IN THE SOFTWARE.
 *
 * $Id: IKoboldServer.java,v 1.16 2004/08/02 14:00:55 garbeam Exp $
 *
 */

package kobold.common.controller;

import java.net.URL;
import java.util.Vector;

import kobold.common.data.AbstractKoboldMessage;
import kobold.common.data.Productline;
import kobold.common.data.User;
import kobold.common.data.UserContext;

/**
 * This class acts as an interface between kobold clients and a
 * kobold server.
 */
public interface IKoboldServer {
	
	public static final String NO_RESULT = "NO_RESULT";

	/**
	 * Login handler.
	 * @param url the server url.
	 * @param userName the username.
	 * @param password the plain text password.
	 * @return UserContext, if the userName and password
	 * 			  is valid. 
	 */
    public UserContext login(URL url, String userName, String password);

	/**
	 * Logout handler.
	 * Invalidates the given user context.
	 * @param userContext the user context.
	 */
    public void logout(UserContext userContext);
	
	/**
	 * Adds an new user to the server.
	 * @param userContext the user context of the valid creator of the
	 * 			  new user (if the new user is a P, than the userContext
	 * 			  must be at least a PE).
	 * @param userName the user name.
	 * @param password the password.
	 * @param fullName the full name.
	 */
	public void addUser(UserContext userContext,
									String userName,
									String password,
									String fullName);
		
    /**
     * Get list of all users.
     * @param userContext
     */
    public Vector getAllUsers(UserContext userContext);
    
	/**
     * Applies modifications to the specified user fullname.
	 * @param userContext the user context
	 * @param user the user name
	 * @param password the decrypted user password verification
     */
    public void updateUserFullName(UserContext userContext,
    					           User user, String password);

	/**
     * Applies modifications to the specified user password.
	 * @param userContext the user context
	 * @param user the user name
	 * @param oldPassword the old password
	 * @param newPassword the new password
     */
    public void updateUserPassword(UserContext userContext,
    					   		   User user, String oldPassword,
    					   		   String newPassword);

	/**
     * Removes the specified user.
     * @param userContext the user context.
     * @param user the user to remove.
     */
    public void removeUser(UserContext userContext, User user);

    /**
     * Fetches a productline by its name.
     * @param userContext the user context.
     * @param id the id of the productline.
     * @return the product line.
     */
    public Productline getProductline(UserContext userContext, String id);

    /**
     * Fetches all product line names.
     * @param userContext the user context.
     * @return {@see java.util.List} of the productline names.
     */
    public Vector getProductlineNames(UserContext userContext);

    /**
	 * Applies modifications to the given Productline.
	 * If you make changes to a specific product or component,
	 * use the specific method instead.
	 * @param userContext the user context.
	 * @param productline the productline. 
	 */
	public void updateProductline(UserContext userContext,
								  Productline id);
    
	/**
	 * Sends a KoboldMessage or WorkflowMessage.
	 * 
	 * @param userContext the user context.
	 * @param koboldMessage the message.
	 */
	public void sendMessage(UserContext userContext,
							AbstractKoboldMessage koboldMessage);
	
	
	/**
	 * Fetches a single KoboldMessage. Should be put to a queue.
	 * Note: to remove the message from Servers message queue,
	 * it has to be invalidated using invalidateMessage!
	 * 
	 * @param userContext the user context.
	 */
	public AbstractKoboldMessage fetchMessage(UserContext userContext);
	

	/**
	 * Invalidates the specified message. This method will remove the message
	 * from Servers message queue.
	 * 
	 * @param userContext the user context.
	 * @param koboldMessage the message.
	 */
	public void invalidateMessage(UserContext userContext,
								  AbstractKoboldMessage koboldMessage);
}
\end{verbatim}
\section{AbstractKoboldMessage}
\small \begin{verbatim}
/*
 * Copyright (c) 2003 - 2004 Necati Aydin, Armin Cont, 
 * Bettina Druckenmueller, Anselm Garbe, Michael Grosse, 
 * Tammo van Lessen,  Martin Plies, Oliver Rendgen, Patrick Schneider
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense, 
 * and/or sell copies of the Software, and to permit persons to whom the 
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in 
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
 * DEALINGS IN THE SOFTWARE.
 *
 * $Id: AbstractKoboldMessage.java,v 1.7 2004/09/23 13:43:17 vanto Exp $
 *
 */
package kobold.common.data;

import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Date;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.dom4j.DocumentHelper;
import org.dom4j.Element;

/**
 * @author garbeam
 */
public abstract class AbstractKoboldMessage implements ISerializable {

	private static final Log logger = LogFactory.getLog(AbstractKoboldMessage.class);
	private DateFormat dateFormat = new SimpleDateFormat("yyMMddHHmmssSZ");
	
	/** this field must be changed if you subclass this class */
	
	public static final String STATE_UN_FETCHED = "UN_FETCHED"; 
	public static final String STATE_FETCHED = "FETCHED";
	public static final String STATE_INVALID = "INVALID";
	
	public static final String PRIORITY_HIGH = "high";
	public static final String PRIORITY_NORMAL = "normal";
	public static final String PRIORITY_LOW = "low";
	
	private String sender;
	private String receiver;
	private String messageText;
	private Date date = new Date();
	private String priority = PRIORITY_NORMAL;
	private String subject;
	private String id;
	private String state = STATE_UN_FETCHED;
	private String productline = "";
	private String role = "";

	/**
	 * Creates a new Kobold Message.
	 * Use this constructor to use a seperate id pool for the given type.
	 * @param idtype
	 */
	protected AbstractKoboldMessage(String idtype)
	{
		id = IdManager.nextId(idtype);
	}

    public String getProductline() {
        return productline;
    }
    public void setProductline(String productline) {
        this.productline = productline;
    }
    public String getRole() {
        return role;
    }
    public void setRole(String role) {
        this.role = role;
    }
	/**
	 * Returns the state.
	 * @return state.
	 */
	public String getState() {
		return state;	
	}
	
	/**
	 * @return
	 */
	public Date getDate() {
		return date;
	}

	/**
	 * @return
	 */
	public String getId() {
		return id;
	}

	public abstract String getType(); 
	
	/**
	 * @return
	 */
	public String getMessageText() {
		return messageText;
	}

	/**
	 * @return
	 */
	public String getPriority() {
		return priority;
	}

	/**
	 * @return
	 */
	public String getReceiver() {
		return receiver;
	}

	/**
	 * @return
	 */
	public String getSender() {
		return sender;
	}

	/**
	 * @return
	 */
	public String getSubject() {
		return subject;
	}

	/**
	 * @param string
	 */
	public void setDate(Date date) {
		this.date = date;
	}

	/**
	 * @param i
	 */
	protected void setId(String id) {
		this.id = id;
	}

	/**
	 * @param string
	 */
	public void setMessageText(String string) {
		messageText = string;
	}

	/**
	 * @param string
	 */
	public void setPriority(String string) {
		priority = string;
	}

	/**
	 * @param string
	 */
	public void setReceiver(String string) {
		receiver = string;
	}

	/**
	 * @param string
	 */
	public void setSender(String string) {
		sender = string;
	}

	/**
	 * @param string
	 */
	public void setSubject(String string) {
		subject = string;
	}

	/**
	 * Serializes this object to an xml element and adds it to the given root.
	 * @param root
	 */
	public Element serialize() {
		Element xmsg = DocumentHelper.createElement("message");
		xmsg.addAttribute("type", getType());
		xmsg.addAttribute("id", id);
		xmsg.addAttribute("priority", priority);
		xmsg.addAttribute("state", state);
		xmsg.addAttribute("productline", productline);
		xmsg.addAttribute("role", role);
		
		if (sender != null) {
		    xmsg.addElement("sender").setText(sender);
		}
		
		if (receiver != null) {
		    xmsg.addElement("receiver").setText(receiver);
		}

		xmsg.addElement("date").setText(date.getTime() + "");

		if (subject != null) {
		    xmsg.addElement("subject").setText(subject);
        } 
		
		if (messageText != null) {
		    xmsg.addCDATA(messageText);
		}	
		
		return xmsg;
	}

	/**
	 * Deserializes message 
	 */
	public void deserialize(Element data) {
		id = data.attributeValue("id");
		priority = data.attributeValue("priority");
		state = data.attributeValue("state");
		productline = data.attributeValue("productline");
		role = data.attributeValue("role");
		
		sender = data.elementTextTrim("sender");
		receiver = data.elementTextTrim("receiver");
		
		// fall back on parse error
		date = new Date();
		String d = data.elementTextTrim("date");
		if (d != null) {
			date.setTime(Long.parseLong(d));
		}

		subject = data.elementTextTrim("subject");

		messageText = data.getTextTrim();
	}


	/**
	 * @see java.lang.Object#equals(java.lang.Object)
	 */
	public boolean equals(Object obj) 
	{
		if (!(obj instanceof AbstractKoboldMessage)) 
			return false;
		return ((AbstractKoboldMessage)obj).getId().equals(getId());
	}

	/**
	 * @see java.lang.Object#hashCode()
	 */
	public int hashCode() 
	{
		return getId().hashCode();
	}

	/**
	 * @see java.lang.Object#toString()
	 */
	public String toString() 
	{
		StringBuffer sb = new StringBuffer(getClass().getName());
		sb.append("\n\t[id:       " + getId() + "]\n");
		sb.append("\t[state:   "  + getState() + "]\n");
		sb.append("\t[sender:   " + getSender() + "]\n");
		sb.append("\t[receiver: " + getReceiver() + "]\n");
		sb.append("\t[subject:  " + getSubject() + "]\n");
		return sb.toString();
	}

	/**
	 * Factorymethod to create a Kobold-/Workflow-instance from an dom4j element.
	 * Checks the type attribute to select the right class, returns null if type
	 * attribute is not set or has wrong data.
	 * 
	 * @param el
	 * @return
	 */
	public static AbstractKoboldMessage createMessage(Element el)
	{
		String type = el.attributeValue("type");
		if (type == null)
			return null;
		
		if (type.equals(KoboldMessage.TYPE)) {
			return new KoboldMessage(el);
		}
		else if (type.equals(WorkflowMessage.TYPE)) {
			return new WorkflowMessage(el);
		}
		else return null;	
	}

	/**
	 * Sets the state.
	 * @param state the state.
	 */
	public void setState(String state) {
		this.state = state;
	}
}

\end{verbatim}
\section{Asset}
\small \begin{verbatim}
/*
 * Copyright (c) 2003 - 2004 Necati Aydin, Armin Cont, 
 * Bettina Druckenmueller, Anselm Garbe, Michael Grosse, 
 * Tammo van Lessen,  Martin Plies, Oliver Rendgen, Patrick Schneider
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense, 
 * and/or sell copies of the Software, and to permit persons to whom the 
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in 
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
 * DEALINGS IN THE SOFTWARE.
 *
 * $Id: Asset.java,v 1.7 2004/08/10 10:31:19 neccaino Exp $
 *
 */
package kobold.common.data;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

import kobold.common.io.RepositoryDescriptor;

import org.dom4j.DocumentHelper;
import org.dom4j.Element;

/**
 * Base class for architectural elements which are managed by the Kobold Server.
 * Implements the {@see kobold.common.data.ISerializable} class for client-server
 * interchange.
 */
public class Asset implements ISerializable {

	public static final String COMPONENT = "component";
	public static final String PRODUCT = "product";
	public static final String PRODUCT_LINE = "productline";

	// resource (file or directory name) of this asset
	private String resource = null;
	// name of this asset
	private String name = null;
	// id of this asset
	private String id = null;
	// type of this asset
	private String type = null;
	// repository location of this asset
	private RepositoryDescriptor repositoryDescriptor = null;
	// maintainers of this asset
	private List maintainer = new ArrayList();
	// parent asset
	private Asset parent = null;
	
	/**
	 * Base constructor for server side assets.
	 * @param parent of this asset, if <code>null</code> this
	 * 		  asset is the root.
	 * @param type the type of this asset, must be a value of the
	 * 		  static final members of this class.
	 * @param id a unique id of this asset.
	 * @param name the name
	 * @param resource the file or directory name (no PATH!)
	 * @param repositoryDescriptor
	 */
	public Asset(Asset parent, String type, String name, String resource,
			     RepositoryDescriptor repositoryDescriptor)
	{
		this.parent = parent;
		this.type = type;
		this.name = name;
		this.resource = resource;
		this.repositoryDescriptor = repositoryDescriptor;
	
		this.id = IdManager.nextId(name);
	}

	
	public Asset(Asset parent) 
	{
	    this.parent = parent;
	}
	
	/**
	 * DOM constructor for deserialization.
	 */
//	public Asset(Asset parent, Element element) {
//		this.parent = parent;
//		deserialize(element);
//	}
	
	/**
	 * Serializes this asset.
	 */
	public Element serialize() {
		Element element = DocumentHelper.createElement(type);
		element.addAttribute("id", this.id);
		element.addAttribute("name", this.name);
		element.addAttribute("resource", this.resource);
		if (parent != null) {
			element.addAttribute("parent-id", parent.getId());
		}
		element.add(repositoryDescriptor.serialize());
		Element maintainerElements = element.addElement("maintainers");
		for (Iterator iterator = maintainer.iterator(); iterator.hasNext(); ) {
			User user = (User) iterator.next();
			maintainerElements.add(user.serialize());
		}
		return element;
	}

	/**
	 * Deserializes this asset.
	 */
	public void deserialize(Element element) {
		this.type = element.getName();
		this.id = element.attributeValue("id");
		this.name = element.attributeValue("name");
		this.resource = element.attributeValue("resource");
		this.repositoryDescriptor =
			new RepositoryDescriptor(element.element("repository-descriptor"));
		Element maintainerElements = element.element("maintainers");
		for (Iterator iterator = maintainerElements.elementIterator("user");
		     iterator.hasNext(); )
		{
			Element elem = (Element) iterator.next();
			maintainer.add(new User(elem));
		}
	}

	/**
	 * Sets the id of this asset.
	 * @param id
	 */
	public void setId(String id) {
	    this.id = id;
	}
	/**
	 * Returns the id of this asset.
	 */
	public String getId() {
		return id;
	}
	
	/**
	 * Returns a list of all maintainer.
	 */
	public List getMaintainers() {
		return maintainer;
	}
	
	/**
	 * Adds new maintainer.
	 * @param user the maintainer.
	 */
	public void addMaintainer(User user) {
		maintainer.add(user);
	}
	
	/**
	 * Removes maintainer.
	 * @param user the maintainer.
	 */
	public void removeMaintainer(User user) {
		maintainer.remove(user);
	}
    
    /**
     * @param username username to check for being assigned maintainer 
     * @return true if a user with the passed username is a maintainer of this
     *         asset, false otherwise
     */
    public boolean isMaintainer(String username){
        Iterator it = maintainer.iterator();
        
        while(it.hasNext()){
            if (((User)it.next()).getUsername().equals(username)){
                return true;
            }
        }
        
        return false;
    }
	
	/**
	 * Returns the name of this asset.
	 */
	public String getName() {
		return name;
	}
	
	/**
	 * Returns the parent asset.
	 */
	public Asset getParent() {
		return parent;
	}
	
	/**
	 * Sets the parent.
	 * @parent parent the parent asset.
	 */
	public void setParent(Asset parent) {
		this.parent = parent;
	}
	
	/**
	 * Returns the repositoryDescriptor.
	 */
	public RepositoryDescriptor getRepositoryDescriptor() {
		return repositoryDescriptor;
	}
	
	/**
	 * Returns the type.
	 */
	public String getType() {
		return type;
	}
	
    public String getResource() {
        return resource;
    }
    
    public void setResource(String resource) {
        this.resource = resource;
    }
}
\end{verbatim}
\section{Component}
\small \begin{verbatim}
/*
 * Copyright (c) 2003 - 2004 Necati Aydin, Armin Cont, 
 * Bettina Druckenmueller, Anselm Garbe, Michael Grosse, 
 * Tammo van Lessen,  Martin Plies, Oliver Rendgen, Patrick Schneider
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense, 
 * and/or sell copies of the Software, and to permit persons to whom the 
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in 
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
 * DEALINGS IN THE SOFTWARE.
 *
 * $Id: Component.java,v 1.5 2004/08/03 16:46:35 garbeam Exp $
 *
 */

package kobold.common.data;

import kobold.common.io.RepositoryDescriptor;

import org.dom4j.Element;

/**
* Represents a server-side component. If the parent is a productline this class
* represents a server-side coreasset. Used for client-server interchange. 
 */
public class Component extends Asset {

	/**
	 * Basic constructor.
	 * @param parent the parent asset, e.g. a product or productline.
	 * @param name the name of this component.
	 * @param resource the resource
	 * @param repositoryDescriptor the repository descriptor of this
	 * 		  component.
	 */
	public Component(Asset parent, String name, String resource,
	                 RepositoryDescriptor repositoryDescriptor)
	{
		super(parent, Asset.COMPONENT, name, resource, repositoryDescriptor);
	}
	
	/**
	 * DOM constructor.
	 * @param parent the parent of this component.
	 * @param element the DOM element representing this component.
	 */
	public Component (Asset parent, Element element) {
		super(parent);
		super.deserialize(element);
	}
	
	/**
	 * Serializes this component.
	 */
	public Element serialize() {
		Element element = super.serialize();
		return element;
	}
}

\end{verbatim}
\section{IdManager}
\small \begin{verbatim}
/*
 * Copyright (c) 2003 - 2004 Necati Aydin, Armin Cont, 
 * Bettina Druckenmueller, Anselm Garbe, Michael Grosse, 
 * Tammo van Lessen,  Martin Plies, Oliver Rendgen, Patrick Schneider
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense, 
 * and/or sell copies of the Software, and to permit persons to whom the 
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in 
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
 * DEALINGS IN THE SOFTWARE.
 *
 * $Id: IdManager.java,v 1.6 2004/07/25 23:17:48 vanto Exp $
 *
 */
package kobold.common.data;

import java.io.IOException;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;

import kobold.common.KoboldCommonsPlugin;

import org.apache.commons.id.IdentifierUtils;
import org.apache.commons.id.uuid.NodeManager;
import org.apache.commons.id.uuid.UUID;
import org.apache.commons.id.uuid.clock.Clock;
import org.apache.commons.id.uuid.state.Node;
import org.apache.commons.id.uuid.state.State;
import org.apache.commons.id.uuid.state.StateHelper;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

/**
 * Provides an id manager using the IETF UUID standard.
 * 
 * @author Tammo van Lessen
 */
public class IdManager 
{
    private static final Log logger = LogFactory.getLog(IdManager.class);
	
	public static String nextId(String idtype) {
		String id = ((UUID)IdentifierUtils.UUID_VERSION_ONE_GENERATOR.nextIdentifier()).toString();
		//logger.debug("new id for "+idtype+": "+id);
		return id;
	}
	
	public static class NodeManagerImpl implements NodeManager {

	    /** Reference to the State implementation to use for loading and storing */
	    private State nodeState;
	    /** The current array index for the Node in use. */
	    private int currentNodeIndex = 0;
	    /** Flag indicating the node state has been initialized. */
	    private boolean isInit = false;
	    /** Set that references all instances. */
	    private Set nodesSet;
	    /** Array of the Nodes */
	    private Node[] allNodes;
	    /** UUID timestamp of last call to State.store */
	    private long lastUUIDTimeStored = 0;
	    
	    public NodeManagerImpl() {
	        // tell common-plugin my instance.
	        KoboldCommonsPlugin.getDefault().setNodeManager(this);
	    }
	    
	    /*** Initialization */
	    public void init() {
	        nodeState = new EclipseUUIDState();
	        nodeState.load();
	        nodesSet = nodeState.getNodes();
	        Iterator it = nodesSet.iterator();
	        allNodes = new Node[nodesSet.size()];
	        int i = 0;
	        while (it.hasNext()) {
	            allNodes[i++] = (Node) it.next();
	        }
	        isInit = true;
	    }
	    
	    public void store() {
	        try {
                nodeState.store(nodesSet);
            } catch (IOException e) {
                // nothing to do here.
            }    
	    }
	    
        /* (non-Javadoc)
         * @see org.apache.commons.id.uuid.NodeManager#currentNode()
         */
        public Node currentNode()
        {
            if (!isInit) {
                init();
            }
            // See if we need to store state information.
            if ((lastUUIDTimeStored + nodeState.getSynchInterval()) > (findMaxTimestamp() / Clock.INTERVALS_PER_MILLI)) {
                try {
                    nodeState.store(nodesSet);
                } catch (IOException ioe) {
                    //@TODO add listener and send notify
                }
            }
            return allNodes[currentNodeIndex];
        }

        /* (non-Javadoc)
         * @see org.apache.commons.id.uuid.NodeManager#nextAvailableNode()
         */
        public Node nextAvailableNode()
        {
            if (!isInit) {
                init();
            }
            currentNodeIndex++;
            if (currentNodeIndex >= allNodes.length) {
                currentNodeIndex = 0;
            }
            return currentNode();        
        }

        /**
         * <p>Returns the maximum uuid timestamp generated from all <code>Node</code>s</p>
         *
         * @return maximum uuid timestamp generated from all <code>Node</code>s.
         */
        private long findMaxTimestamp() {
            if (!isInit) {
                init();
            }
            long max = 0;
            for (int i = 0; i < allNodes.length; i++) {
                if (allNodes[i] != null && allNodes[i].getLastTimestamp() > max) {
                    max = allNodes[i].getLastTimestamp();
                }
            }
            return max;
        }
        
        public void lockNode(Node arg0)
        {
            // not implemented
        }
        public void releaseNode(Node arg0)
        {
            // not implemented
        }
	    
	}
	
	private static class EclipseUUIDState implements State
	{
	    private HashSet nodes = new HashSet(1);
	    private Node node = null;
	    
	    /**
	     * @see org.apache.commons.id.uuid.state.State#load()
	     */
	    public void load() throws IllegalStateException
	    {
	        String nodeId = KoboldCommonsPlugin.getDefault().getPluginPreferences().getString("uuid-nodeid");
	        long lastTime = KoboldCommonsPlugin.getDefault().getPluginPreferences().getLong("uuid-lasttime");
	        short seq = (short)KoboldCommonsPlugin.getDefault().getPluginPreferences().getInt("uuid-clockseq");
	        
	        node = null;
	        if ("".equals(nodeId)) {
	            logger.debug("no node found, creating a new one");
	            node = new Node(StateHelper.randomNodeIdentifier());    
	        } else {
	            logger.debug("node found. using node "+ nodeId +"");
	            node = new Node(StateHelper.decodeMACAddress(nodeId), lastTime, seq);
	        }
	        
	        nodes.add(node);
	    }

	    /**
	     * @see org.apache.commons.id.uuid.state.State#getNodes()
	     */
	    public Set getNodes()
	    {
	        return nodes;
	    }

	    /**
	     * @see org.apache.commons.id.uuid.state.State#store(java.util.Set)
	     */
	    public void store(Set arg0) throws IOException
	    {
	        KoboldCommonsPlugin.getDefault().getPluginPreferences().setValue("uuid-nodeid", StateHelper.encodeMACAddress(node.getNodeIdentifier()));
	        KoboldCommonsPlugin.getDefault().getPluginPreferences().setValue("uuid-lasttime", node.getLastTimestamp());
	        KoboldCommonsPlugin.getDefault().getPluginPreferences().setValue("uuid-clockseq", node.getClockSequence());
	        KoboldCommonsPlugin.getDefault().savePluginPreferences();
	        logger.debug("uuid node stored.");
	    }

	    /**
	     * @see org.apache.commons.id.uuid.state.State#store(java.util.Set, long)
	     */
	    public void store(Set arg0, long arg1)
	    {
	       logger.error("store(Set, int) not implemented!");
	    }

	    /**
	     * @see org.apache.commons.id.uuid.state.State#getSynchInterval()
	     */
	    public long getSynchInterval()
	    {
	        return 3000;//Long.MAX_VALUE;
	    }

	}

}

\end{verbatim}
\section{KoboldMessage}
\small \begin{verbatim}
/*
 * Copyright (c) 2003 - 2004 Necati Aydin, Armin Cont, 
 * Bettina Druckenmueller, Anselm Garbe, Michael Grosse, 
 * Tammo van Lessen,  Martin Plies, Oliver Rendgen, Patrick Schneider
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense, 
 * and/or sell copies of the Software, and to permit persons to whom the 
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in 
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
 * DEALINGS IN THE SOFTWARE.
 *
 * $Id: KoboldMessage.java,v 1.12 2004/05/18 18:47:33 vanto Exp $
 *
 */
package kobold.common.data;

import org.dom4j.Element;

/**
 * @author Tammo
 */
public class KoboldMessage extends AbstractKoboldMessage 
{
    public static final String TYPE = "kobold";
    
	/**
	 * Creates a new Kobold Message with a new unique id. (type = kmesg).
	 */
	public KoboldMessage()
	{
		super("kmesg");
	}

	/**
	 * Unmarshals a Kobold Message.
	 * @param data
	 */
	public KoboldMessage(Element data)
	{
		this();
		super.deserialize(data);
	}

    /**
     * @see kobold.common.data.AbstractKoboldMessage#getType()
     */
    public String getType()
    {
   		return KoboldMessage.TYPE;
    }

}

\end{verbatim}
\section{Product}
\small \begin{verbatim}
/*
 * Copyright (c) 2003 - 2004 Necati Aydin, Armin Cont, 
 * Bettina Druckenmueller, Anselm Garbe, Michael Grosse, 
 * Tammo van Lessen,  Martin Plies, Oliver Rendgen, Patrick Schneider
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense, 
 * and/or sell copies of the Software, and to permit persons to whom the 
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in 
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
 * DEALINGS IN THE SOFTWARE.
 *
 * $Id: Product.java,v 1.16 2004/09/23 13:43:17 vanto Exp $
 *
 */

package kobold.common.data;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;

import kobold.common.io.RepositoryDescriptor;

import org.dom4j.Element;

/**
 * Represents a server side product. Used for client-server interchange.
 */
public class Product extends Asset {

	private List components = new ArrayList(); //TODO: remove when finally changing to id mapping
    
    // change this to false to test server side id mapping
    private static final boolean stickToNameMapping = true;

    private HashMap componentsMap = new HashMap();
	
	/**
	 * Basic constructor.
	 * @param productline the parent productline.
	 * @param name the name of this product.
	 * @param resource the file or directory name
	 * @param repositoryDescriptor the repository descriptor of this product.
	 */
	public Product (Productline productline, String name, String resource,
	               RepositoryDescriptor repositoryDescriptor) {
		super(productline, Asset.PRODUCT, name, resource, repositoryDescriptor);
	}
	
	/**
	 * DOM constructor.
	 * @param productline the parent productline.
	 * @param the DOM element representing this asset.
	 */
	public Product (Productline productline, Element element) {
	    super(productline);
		deserialize(element);
	}
	
	/**
	 * Returns all components of this product.
     * @return List containing all registered components
	 */
	public List getComponents() {
        // will be removed when change to id mapping can be made risklessly
        if (stickToNameMapping) {
            return getComponentsNameMapping();
        }
		
        List ret = new ArrayList();
        for (Iterator it = componentsMap.values().iterator(); it.hasNext();) {
            ret.add(it.next());
        }
        
        return ret;
	}
	
    // will be removed when change to id mapping can be made risklessly
	private List getComponentsNameMapping() {
        return components;
    }
    
	/**
	 * Adds new component to this product.
	 * @param component the component.
	 */
    public void addComponent(Component component) {
        // will be removed when change to id mapping can be made risklessly
        if (stickToNameMapping) {
            addComponentNameMapping(component);
            return;
        }
        
        componentsMap.put(component.getId(), component);
    }
    
    // will be removed when change to id mapping can be made risklessly
	private void addComponentNameMapping(Component component) {
		components.add(component);
	}

	/**
	 * Removes an existing component from this product.
	 * @param component the component.
	 */
	public void removeComponent(Component component) {
        // will be removed when change to id mapping can be made risklessly
		if (stickToNameMapping) {
            removeComponentNameMapping(component);
            return;
        }
        
        componentsMap.remove(component.getId());
    }
    
    // will be removed when change to id mapping can be made risklessly
    private void removeComponentNameMapping(Component component) {
		components.remove(component);
	}
    
    /**
     * Returns a component by its id
     * @param id id of the component to get
     * @return the component with the specified id or null if no such component
     *         exists
     */
    public Component getComponent(String id) {
        return (Component) componentsMap.get(id);
    }

	/**
	 * Serializes this product.
	 */
	public Element serialize() {
        // will be removed when change to id mapping can be made risklessly
		if (stickToNameMapping) {
            return serializeNameMapping();
        }
        
		Element element = super.serialize();
		
		Element compElements = element.addElement("components");
		for (Iterator iterator = componentsMap.values().iterator(); iterator.hasNext(); ) {
			Component component = (Component) iterator.next();
			compElements.add(component.serialize());
		}
		
		return element;
	}
	
    // will be removed when change to id mapping can be made risklessly
    public Element serializeNameMapping() {
        Element element = super.serialize();
        
        Element compElements = element.addElement("components");
        for (Iterator iterator = components.iterator(); iterator.hasNext(); ) {
            Component component = (Component) iterator.next();
            compElements.add(component.serialize());
        }
        
        return element;
    }

    /**
	 * Deserializes this product. It's asserted that super deserialization
	 * is already finished.
	 * @param element the DOM element representing this product.
	 */
    public void deserialize(Element element) {
        // will be removed when change to id mapping can be made risklessly
        if (stickToNameMapping) {
            deserializeNameMapping(element);
            return;
        }
        
        super.deserialize(element);
        Element compElements = element.element("components");
        
        for (Iterator iterator = compElements.elementIterator(Asset.COMPONENT);
             iterator.hasNext(); )
        {
            Element elem = (Element) iterator.next();
            Component c = new Component(this, elem);
            componentsMap.put(c.getId(), c);
        }
    }
    
    
    // will be removed when change to id mapping can be made risklessly
	private void deserializeNameMapping(Element element) {
		super.deserialize(element);
	    Element compElements = element.element("components");
		
		for (Iterator iterator = compElements.elementIterator(Asset.COMPONENT);
			 iterator.hasNext(); )
		{
			Element elem = (Element) iterator.next();
			components.add(new Component(this, elem)); 
		}
	}
}

\end{verbatim}
\section{Productline}
\small \begin{verbatim}
/*
 * Copyright (c) 2003 - 2004 Necati Aydin, Armin Cont, 
 * Bettina Druckenmueller, Anselm Garbe, Michael Grosse, 
 * Tammo van Lessen,  Martin Plies, Oliver Rendgen, Patrick Schneider
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense, 
 * and/or sell copies of the Software, and to permit persons to whom the 
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in 
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
 * DEALINGS IN THE SOFTWARE.
 *
 * $Id: Productline.java,v 1.23 2004/09/23 13:43:17 vanto Exp $
 *
 */
package kobold.common.data;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import kobold.common.io.RepositoryDescriptor;

import org.dom4j.Element;


/**
 * This class represents a server side productline. Productlines consist of
 * several products, they can be assigned Users (Productline engineers) who
 * have the right to modify it and they encapsulate the necessary information 
 * about the repository where the actual products are stored.
 * 
 * They are created (and removed) by the corresponding administration methods 
 * and stored directly on the Kobold server. 
 * 
 * @see kobold.server.controller.SecureKoboldWebServer
 * @see kobold.common.data.Product
 * @see kobold.common.io.RepositoryDescriptor 
 */
public class Productline extends Asset {

	private Map coreassets = new HashMap();
	private Map products = new HashMap();
    
    // change this to false to test server side id mapping
    private static final boolean stickToNameMapping = true;
	
	/**
	 * Base constructor for productlines.
	 * @param name the name of this productline.
	 * @param resource the file or directory name.
	 * @param repositoryDescriptor containing the necessary information about
	 *        this productlines repository
	 */
	public Productline(String name, String resource, RepositoryDescriptor repositoryDescriptor) {
		super(null, Asset.PRODUCT_LINE, name, resource, repositoryDescriptor);
	}

	/**
	 * DOM constructor for server-side productlines.
	 * @param element the DOM element representing this productline.
	 */
	public Productline(Element element) {
		super(null);
		deserialize(element);
	}

	/**
	 * Adds a new product to this productline. Please note that each registered
     * product needs to have its own (unique) name. Adding of a prodct with a
     * name that has already been registered will be refused. 
     * 
	 * @param product the product to add.
     * @return true, if the passed productline could be added successfully, 
     *         false otherwise
	 */
	public boolean addProduct(Product product) {
        // will be removed when change to id mapping can be made risklessly
        if (stickToNameMapping) {
            return addProductNameMapping(product);
        }
        
        // 1.) refuse adding if product's name is already registered
        if (getProductByName(product.getName()) != null) {
            return false;
        }
        
        // 2.) set parent and add 
        product.setParent(this);
		products.put(product.getId(), product);
		return true;
	}
	
    // will be removed when change to id mapping can be made risklessly
    private boolean addProductNameMapping(Product product) {
        Object o = products.put(product.getName(), product);
        
        if (o != null){
            // a product with the same name as the one to add already exists
            // => undo the change and signal error
            products.put(product.getName(), o);
            return false;
        }
        else{
            product.setParent(this);
            return true;
        }
    }
    
	/**
	 * Gets a product by its id.
     *  
	 * @param productId the product's id.
     * @return the product with the specified id or null if no product with
     *         that id exists
	 */
	public Product getProduct(String productId) {
	    return (Product)products.get(productId);
	}
	
    /**
     * Gets a product by its name
     * 
     * @param productName name of the product to get
     * @return Product with the specified name or null if no product with that
     *         name exists
     */
    public Product getProductByName(String productName) {
        for(Iterator it = products.values().iterator(); it.hasNext();) {
            Product p = (Product) it.next();
            if (p.getName().equals(productName)) {
                return p;
            }
        }
        
        return null; //no registered product with that name
    }
    
	/**
	 * Gets a coreasset by its id.
	 * @param coreAssetId the coreasset's id.
     * @return the coreasset with the specified id or null if no coreasset with
     *         that id exists
	 */
	public Component getCoreAsset(String coreAssetId) {
	    return (Component)products.get(coreAssetId);
	}
    
    /**
     * Gets a coreasset by its name.
     *  
     * @param coreAssetName name of the coreasset to get.
     * @return the coreasset with the specified name or null if no coreasset 
     *         with that name exists
     */
    public Component getCoreAssetByName(String coreAssetName) {
        for(Iterator it = coreassets.values().iterator(); it.hasNext();) {
            Component c = (Component) it.next();
            if (c.getName().equals(coreAssetName)) {
                return c;
            }
        }
        
        return null; //no registered core asset with that name
    }
	
	/**
     * Gets all products.
     * @return List containing every registered product
	 */
	public List getProducts() {
	    return new ArrayList(products.values());
	}
	
	/**
	 * Gets all coreassets.
     * @return List containing every registered core asset
	 */
	public List getCoreAssets() {
	    return new ArrayList(coreassets.values());
	}
	
	/**
	 * Removes a product by its id.
	 * @param productId the product's id.
     * @return the removed Product if a product with the passed id existed, null 
     *         otherwise
	 */
	public Product removeProduct(String productId) {
		Product ret = (Product) products.remove(productId);
        
        if (ret != null){
        	ret.setParent(null);
        }
        
        return ret;
	}
    
    /**
     * Removes a product by its name.
     * 
     * @param productName name of the product to remove
     * @return the removed Product object, or null if no product with the 
     *         specified name exists
     */
    public Product removeProductByName(String productName) {
        String id = getProductIdByName(productName);
        return id == null ? null : removeProduct(id);
    }
    
    /**
     * @param productName name of the product whose id should be returned
     * @return id of the product with the specified name or null if no such
     *         product exists
     */
    public String getProductIdByName(String productName) {
        Product p = getProductByName(productName);
        return p == null ? null : p.getId();
    }

	/**
	 * Adds new core asset to this productline. Please note that each registered
     * coreasset needs to have its own (unique) name. Adding of a ca with a
     * name that has already been registered will be refused. 
     * 
	 * @param coreasset the coreasset to add.
     * @return true if the passed coreasset could be registered successfully,
     *         false otherwise
	 */
	public boolean addCoreAsset(Component coreasset) {
        // will be removed when change to id mapping can be made risklessly
        if (stickToNameMapping) {
            return addCoreAssetNameMapping(coreasset);
        }
        
        // 1.) refuse adding if coreasset's name is already registered
        if (getCoreAssetByName(coreasset.getName()) != null) {
            return false;
        }
        
        // 2.) set parent and add
        coreasset.setParent(this);
        coreassets.put(coreasset.getId(), coreasset);
        return true;
	}
    
    // will be removed when change to id mapping can be made risklessly
    private boolean addCoreAssetNameMapping(Component coreasset) {
        Object o = coreassets.put(coreasset.getName(), coreasset);
        
        if (o != null){
            coreassets.put(coreasset.getName(), o);
            return false;
        }
        else{
            coreasset.setParent(this);
            return true;
        }
    }
	
	/**
	 * Removes a coreasset by its id.
	 * @param coreasset the coreassset to remove.
     * @return the removed coreasset if a core asset with the specified id 
     *         existed, null otherwise 
	 */
	public Component removeCoreAsset(String coreAssetId) {
		Component ret = (Component) coreassets.remove(coreAssetId);
        
        if (ret != null){
        	ret.setParent(null);
        }
        
        return ret;
	}
    
    /**
     * Removes a core asset by its name.
     * 
     * @param coreAssetName name of the core asset to remove
     * @return the removed core asset or null if no core asset with the 
     *         specified name exists
     */
    public Component removeCoreAssetByName(String coreAssetName) {
        String id = getCoreAssetIdByName(coreAssetName);
        return id == null ? null : removeCoreAsset(id);
    }

    /**
     * @param coreAssetName name of the core asset whose id should be returned
     * @return id of the core asset with the specified name or null if no such
     *         product exists
     */
    public String getCoreAssetIdByName(String coreAssetName) {
        Component c = getCoreAssetByName(coreAssetName);
        return c == null ? null : c.getId();
    }
    
	/**
	 * Serializes this productline.
	 */
	public Element serialize() {
		Element element = super.serialize();

		Element coreassetElements = element.addElement("coreassets");
		for (Iterator iterator = coreassets.values().iterator(); iterator.hasNext(); ) {
			Component component = (Component) iterator.next();
			coreassetElements.add(component.serialize());
		}
		
		Element productElements = element.addElement("products");
		for (Iterator iterator = products.values().iterator(); iterator.hasNext(); ) {
			Product product = (Product) iterator.next();
			productElements.add(product.serialize());
		}

		return element;
	}

	/**
	 * Deserializes this productline. It's asserted that super deserialization
	 * is already finished.
	 * @param element the DOM element representing this productline.
	 */
	public void deserialize(Element element) {
        // will be removed when change to id mapping can be made risklessly
        if (stickToNameMapping) {
            deserializeNameMapping(element);
            return;
        }

		super.deserialize(element);
	    Element coreassetElements = element.element("coreassets");
		for (Iterator iterator = coreassetElements.elementIterator(Asset.COMPONENT);
			 iterator.hasNext(); )
		{
			Element elem = (Element) iterator.next();
			addCoreAsset(new Component(this, elem));
		}
		
		Element productElements = element.element("products");
		for (Iterator iterator = productElements.elementIterator(Asset.PRODUCT);
			 iterator.hasNext(); )
		{
			Element elem = (Element) iterator.next();
			addProduct(new Product(this, elem));
		}
	}
    
    // will be removed when change to id mapping can be made risklessly
    private void deserializeNameMapping(Element element) {
        super.deserialize(element);
        Element coreassetElements = element.element("coreassets");
        for (Iterator iterator = coreassetElements.elementIterator(Asset.COMPONENT);
             iterator.hasNext(); )
        {
            Element elem = (Element) iterator.next();
            Component component = new Component(this, elem);
            coreassets.put(component.getName(), component);
        }
        
        Element productElements = element.element("products");
        for (Iterator iterator = productElements.elementIterator(Asset.PRODUCT);
             iterator.hasNext(); )
        {
            Element elem = (Element) iterator.next();
            Product product = new Product(this, elem);
            products.put(product.getName(), product);
        }
    }
}
\end{verbatim}
\section{RPCSpy}
\small \begin{verbatim}
/*
 * Copyright (c) 2003 - 2004 Necati Aydin, Armin Cont, 
 * Bettina Druckenmueller, Anselm Garbe, Michael Grosse, 
 * Tammo van Lessen,  Martin Plies, Oliver Rendgen, Patrick Schneider
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense, 
 * and/or sell copies of the Software, and to permit persons to whom the 
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in 
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
 * DEALINGS IN THE SOFTWARE.
 *
 * $Id: RPCSpy.java,v 1.1 2004/06/23 13:27:26 garbeam Exp $
 *
 */

package kobold.common.data;

import java.util.Vector;

/**
 * Container for RPC call sniffing.
 */
public class RPCSpy {
	
	private String methodName = null;
	private Vector arguments = null;
	
	/**
	 * Clones all RPC stuff.
	 * @param methodName the method which has been invoked.
	 * @param arguments the argument container.
	 */
	public RPCSpy(String methodName, Vector arguments) {
		this.methodName = methodName;
		this.arguments = arguments;
	}
	
	/**
	 * @return Returns the arguments.
	 */
	public Vector getArguments() {
		return arguments;
	}
	/**
	 * @return Returns the methodName.
	 */
	public String getMethodName() {
		return methodName;
	}
}
 
\end{verbatim}
\section{User}
\small \begin{verbatim}
/*
 * Copyright (c) 2003 - 2004 Necati Aydin, Armin Cont, 
 * Bettina Druckenmueller, Anselm Garbe, Michael Grosse, 
 * Tammo van Lessen,  Martin Plies, Oliver Rendgen, Patrick Schneider
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense, 
 * and/or sell copies of the Software, and to permit persons to whom the 
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in 
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
 * DEALINGS IN THE SOFTWARE.
 *
 * $Id: User.java,v 1.14 2004/07/07 15:40:32 garbeam Exp $
 *
 */
package kobold.common.data;


import org.dom4j.DocumentHelper;
import org.dom4j.Element;


/**
 * Provides a user representation on the client side.
 * 
 * Implements ISerializable to make the tranport through XMLRPC possible.
 * 
 * @author Tammo
 */
public class User implements ISerializable
{
    private String username;
    private String fullname;
    
    
    public User(String username, String fullname)
    {
        this.username = username;
        this.fullname = fullname;
    }
    
    public User(Element element) {
    	deserialize(element);
    }
    
    /**
     * @param fullname The fullname to set.
     */
    public void setFullname(String fullname)
    {
        this.fullname = fullname;
    }
    
    /**
     * @return Returns the fullname.
     */
    public String getFullname()
    {
        return fullname;
    }
    
    /**
     * @param username The username to set.
     */
    public void setUsername(String username)
    {
        this.username = username;
    }
    
    /**
     * @return Returns the username.
     */
    public String getUsername()
    {
        return username;
    }

    /**
     * @see kobold.common.data.ISerializable#serialize()
     */
    public Element serialize()
    {
        Element user = DocumentHelper.createElement("user");
        if (username != null) {
            user.addAttribute("username", username);   
        }
        
        if (fullname != null) {
            user.addAttribute("fullname", fullname);
        }
        
        return user;
    }

    /**
     * @see kobold.common.data.ISerializable#deserialize(org.dom4j.Element)
     */
    public void deserialize(Element element)
    {
       username = element.attributeValue("username");
       fullname = element.attributeValue("fullname");
    }
    
    public boolean equals(Object obj)
    {
        if (obj instanceof User) {
            return getUsername().equals(((User)obj).getUsername());
        }
        return false;
    }
    
    public int hashCode()
    {
        return getUsername().hashCode();
    }
}

\end{verbatim}
\section{UserContext}
\small \begin{verbatim}
/*
 * Copyright (c) 2004 Armin Cont, Anselm R. Garbe, Bettina Druckenmueller,
 *                    Martin Plies, Michael Grosse, Necati Aydin,
 *                    Oliver Rendgen, Patrick Schneider, Tammo van Lessen
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 * 
 * $Id: UserContext.java,v 1.10 2004/08/02 14:00:55 garbeam Exp $
 */

package kobold.common.data;

import java.net.URL;

import org.dom4j.DocumentHelper;
import org.dom4j.Element;

/**
 * Base class for user context information (session info).
 * This class provides information about the current user context
 * which is the session info.
 *
 * @author garbeam
 */
public class UserContext implements ISerializable {
	// members
	private String userName;
	private String sessionId;
	private URL serverUrl = null;
	
    /**
     * DOM constructor for user contexts.
	 * @param element the DOM element represendting this user context.
	 */
	public UserContext(Element element) {
		deserialize(element);
	}


    /**
     * Default constructor, which provides basic info
     * about the user context.
     * This class could be used to determine more information
     * about the specific user context from the Kobold server,
     * e.g. roles, repository access data, etc.
     *
     * @param username username of the users (like a Unix username).
     * @param sessionId the current session Id of the user context.
     */
    public UserContext(String userName, String sessionId)
    {
        this.userName = userName;
        this.sessionId = sessionId;
    }

    /**
     * @returns the username of this user context.  
     */
    public String getUserName() {
        return this.userName;
    }

    /**
     * @returns the session id of this user context.
     */
    public String getSessionId() {
        return this.sessionId;
    }

	/**
	 * Sets sessionId.
	 */
	public void setSessionId(String sessionId) {
		this.sessionId = sessionId;
	}
	
	/**
	 * Serializes this object.
	 * 
	 * @return DOM Element representing this object.
	 */
	public Element serialize() {
		Element userContext = DocumentHelper.createElement("usercontext");
		userContext.addElement("username").addText(this.userName);
		userContext.addElement("session-id").addText(this.sessionId);
		
		return userContext;
	}
	
	/**
	 * Deserializes this object.
	 * @param element the DOM element representing this object.
	 */
	public void deserialize(Element element) {
		this.userName = element.elementText("username");
		this.sessionId = element.elementText("session-id");
	}
	
    public URL getServerUrl() {
        return serverUrl;
    }
    
    public void setServerUrl(URL serverUrl) {
        this.serverUrl = serverUrl;
    }
}
\end{verbatim}
\section{WorkflowItem}
\small \begin{verbatim}
/*
 * Copyright (c) 2003 - 2004 Necati Aydin, Armin Cont, 
 * Bettina Druckenmueller, Anselm Garbe, Michael Grosse, 
 * Tammo van Lessen,  Martin Plies, Oliver Rendgen, Patrick Schneider
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense, 
 * and/or sell copies of the Software, and to permit persons to whom the 
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in 
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
 * DEALINGS IN THE SOFTWARE.
 *
 * $Id: WorkflowItem.java,v 1.7 2004/05/19 16:08:34 martinplies Exp $
 *
 */
package kobold.common.data;

import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;

import org.dom4j.DocumentHelper;
import org.dom4j.Element;

/**
 * @author pliesmn
 *
 * A WorkflowItem is a Checkbutton, a Radiobutton or a  single-Line-TextWindow
 * The data, to display a WorkFlowItem is stored here.  
 * 
 */
public class WorkflowItem {

	public final static String TEXT = "text"; 
	public final static String CHECK = "check";
	public final static String RADIO = "radio";
	public final static String CONTAINER = "container";
	
	private String description;
	private String value; // The Name of the Checkbutton or Textwindow or the value of the Radiobutton 
	private String type;
	private List children = new LinkedList();
	
	public WorkflowItem(Element data)
	{
		deserialize(data);
	}

	/**
	 * Creates a new WorkflowItem object.
	 * 
	 * There are 4 different kinds of workflow items:
	 *  <ul>
	 * 		<li>type = TEXT: value = text in inputarea, description, no children<li> 
	 * 		<li>type = CHECK: value = "true"|"false", description, no children<li>
	 * 		<li>type = RADIO: value = "true"|"false", description, must be added to a 
	 * 			CONTAINER item, no children<li>
	 * 		<li>type = CONTAINER: value = undefined|null, description, RADIO items as children<li>
	 * 	</ul>
	 *    
	 * @param nameValue
	 * @param description
	 * @param type
	 */
	public WorkflowItem(String value, String description, String type) {
		this.value = value;
		this.description = description;
		this.type = type;
	}

	
	public void addChild(WorkflowItem control)
	{
		if (!type.equals(WorkflowItem.CONTAINER))
			throw new IllegalArgumentException("illegal add");
		children.add(control);	
	}
	
	
	public void addChildren(WorkflowItem[] control)
	{
		if (!type.equals(WorkflowItem.CONTAINER))
			throw new IllegalArgumentException("illegal add");
		for (int itemNr =0; itemNr <  control.length; itemNr++)
		  children.add(control[itemNr]);	
	}
	
	public WorkflowItem[] getChildren()
	{
		return (WorkflowItem[])children.toArray(new WorkflowItem[0]);	
	}
	
	public String getType() {
		return type;
	}
	
	public String getValue(){
		return value;
	}
	
	public String getDescription() {
		return this.description;
	}
	
	public Element serialize()
	{
		Element element = DocumentHelper.createElement("control");
		element.addElement("type").setText(type);
		element.addElement("description").setText(description);
		element.addElement("value").setText(value);
		
		if (type.equals(WorkflowItem.CONTAINER)) {
			Element childrenEl = element.addElement("children");
			Iterator it = children.iterator();
			while (it.hasNext()) {
				WorkflowItem wfi = (WorkflowItem)it.next();
				childrenEl.add(wfi.serialize());
			}			
		}		
		return element;
	}
	
	protected void deserialize(Element data)
	{
		type = data.elementTextTrim("type");
		value = data.elementTextTrim("value");
		description = data.elementTextTrim("description");
		
		Element childrenEl = data.element("children");
		if (type.equals(WorkflowItem.CONTAINER) && childrenEl != null) {
			children.clear();
			Iterator it = childrenEl.elementIterator("control");
			while (it.hasNext()) {
				Element control = (Element)it.next();
				children.add(new WorkflowItem(control));	
			}
		}
	}

	public void setValue(String value) 
	{
		this.value = value;
	}
	
}

\end{verbatim}
\section{WorkflowMessage}
\small \begin{verbatim}
/*
 * Copyright (c) 2003 - 2004 Necati Aydin, Armin Cont, 
 * Bettina Druckenmueller, Anselm Garbe, Michael Grosse, 
 * Tammo van Lessen,  Martin Plies, Oliver Rendgen, Patrick Schneider
 * 
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense, 
 * and/or sell copies of the Software, and to permit persons to whom the 
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in 
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
 * DEALINGS IN THE SOFTWARE.
 *
 * $Id: WorkflowMessage.java,v 1.26 2004/09/23 13:43:17 vanto Exp $
 *
 */
package kobold.common.data;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.dom4j.Element;

/**
 
 * @author garbeam
 * @author vanto
 */
public class WorkflowMessage extends AbstractKoboldMessage {
	
	public static final String TYPE = "workflow";
	public static final String DATA_VALUE_TRUE = "TRUE";
	public static final String DATA_VALUE_FALSE= "FALSE";
	private String workflowType = new String();
	private String comment = "";
	private Set parents = new HashSet();
	private List controlItems = new LinkedList(); // ArrayList performs much better
	private HashMap workflowData = new HashMap();
	private int step;


	/**
	 * Creates a Workflow Message in the 'workflow' id namespace
	 */
	public WorkflowMessage(String workflowType)
	{
		super(TYPE);
		this.workflowType = workflowType;
	}
	
	/**
	 * Creates a Workflow Message and deserializes its data from xml
	 * 
	 * @param data a &lt;message&gt; element
	 */
	public WorkflowMessage(Element data)
	{
		super(TYPE);
	    deserialize(data);
	}
	
	public void addParentId(String id)
	{
		parents.add(id);
	}
	
	public String[] getParentIds()
	{
		return (String[])parents.toArray(new String[0]);	
	}
	
	public void addWorkflowControl(WorkflowItem item)
	{
		controlItems.add(item);
	}
	
	public WorkflowItem[] getWorkflowControls()
	{
		return (WorkflowItem[])controlItems.toArray(new WorkflowItem[0]);
	}
	
	/**
	 * @return
	 */
	public String getComment() {
		return comment;
	}


	/**
	 * Sets the Workflow ID. 
	 * This ID describes, which Workflow should be applied by Drools

	 * @return workflow id
	 */
	public String getWorkflowType() {
		return workflowType;
	}

	/**
	 * @param string
	 */
	public void setComment(String string) {
		comment = string;
	}

	/**
	 * Sets the Workflow ID. 
	 * This ID describes, which Workflow should be applied by Drools
	 */
	public void setWorkflowType(String type) {
		workflowType = type;
	}
	
	/**
	 * @return
	 */
	public Map getWorkflowData() {
		return workflowData;
	}	
	
	public void putWorkflowData(String key, String value) {
		this.workflowData.put(key, value);
	}	
	
	public String getWorkflowDate(String key) {
		return (String) this.workflowData.get(key);
	}

	/**
	 * @see kobold.common.data.KoboldMessage#deserialize(org.dom4j.Element)
	 */
	public void deserialize(Element data) 
	{
		super.deserialize(data);
		// TODO check why those slutty variables dont get initialized.
		//parents = new HashSet();
		//controlItems = new LinkedList();
		
		workflowType = data.elementTextTrim("workflow-id");
		comment = data.elementTextTrim("comment");
		step = Integer.valueOf(data.elementTextTrim("step")).intValue();

		Element history = data.element("history");
		Iterator it = history.elementIterator("parent");
		
		while (it.hasNext()) {
			Element p = (Element)it.next();
			parents.add(p.getTextTrim());
		}
		
		Element controls = data.element("controls");
		it = controls.elementIterator("control");

		while (it.hasNext()) {
			Element c = (Element)it.next();
			controlItems.add(new WorkflowItem(c));
		}
		
		Element answers = data.element("results");
		it = answers.elementIterator();
		
		while (it.hasNext()) {
			Element a = (Element) it.next();
			this.putWorkflowData(a.getName(), a.getTextTrim());
		}

	}

	public String getType() 
	{
		return WorkflowMessage.TYPE;
	}

	/**
	 * @see kobold.common.data.KoboldMessage#serialize()
	 */
	public Element serialize() 
	{
		Element el = super.serialize();
		el.addElement("workflow-id").setText(workflowType);
		el.addElement("comment").addCDATA(comment);
		el.addElement("step").setText(String.valueOf(step));
		
		Element hist = el.addElement("history");
		Iterator it = parents.iterator();
		while (it.hasNext()) {
			String id = (String)it.next();
			hist.addElement("parent").setText(id);
		}
		
		Element controls = el.addElement("controls");
		it = controlItems.iterator();
		while (it.hasNext()) {
			WorkflowItem control = (WorkflowItem)it.next();
			controls.add(control.serialize());
		}
		
		// store answers
		Element answers = el.addElement("results");
		it = workflowData.keySet().iterator();
		while (it.hasNext()) {
			String key = (String) it.next();
			answers.addElement(key).setText((String) workflowData.get(key));
		}
		return el;
	}

	public String toString() {
		StringBuffer sb = new StringBuffer();
		sb.append("\t[wf-id:    " + getWorkflowType() + "]\n");
		sb.append("\t[parents:  " + getParentIds().length + "]\n");
		sb.append("\t[controls: " + getWorkflowControls().length + "]\n");

		return super.toString() + sb.toString(); 
	}
	/**
	 * @return Returns the step.
	 */
	public int getStep() {
		return step;
	}
	/**
	 * @param step The step to set.
	 */
	public void setStep(int step) {
		this.step = step;
	}
}   
   


\end{verbatim}