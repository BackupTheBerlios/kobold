\documentclass[a4paper,titlepage,12pt,ngerman]{scrbook}
\usepackage{../common/header}
\RequirePackage{hhline}

\RCSdef $Revision: 1.0 $
\RCSdef $Date: 2004/10/25 $

\newcommand\version{Version 1.0 \xspace}

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Deckblatt

\begin{titlepage}
\renewcommand{\thefootnote}{\fnsymbol{footnote}}
{\Huge
\raggedright
\textbf{\bf Kobold} \\
\huge Product Line Management System
\rule{\textwidth}{0.75pt}
\par
}
\begin{flushleft}
\normalsize
\version
\end{flushleft}


\vfill
\includegraphics[width=15cm]{../common/logo-color.png}
\vfill
{\parindent=0cm
\Huge Abschlussbericht
}


\setcounter{footnote}{0}
\end{titlepage}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Versionsgeschichte

\section*{Versionsgeschichte}

\begin{itemize}

\item Version 1.0 

\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Inhaltsverzeichnis

\tableofcontents

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Einleitung}

\section{Zweck des Dokuments}

Dieses Dokument beschreibt das Projekt ``Produktlinien'', das von Anfang Oktober
 2003 bis Anfang November 2004 an der
Universität Stuttgart am Institut für Softwaretechnologie (ISTE) durchgeführt
wurde. Das Projekt wurde von neun Softwaretechnik Studenten - Necati
Aydin, Anselm Garbe, Tammo van Lessen, Michael Grosse, Armin Cont, Patrick Schneider,
Oliver Rendgen, Martin Plies und Bettina Druckenmüller - im Rahmen eines Studienprojekts A
durchgeführt. Im Folgenden wird ein Überblick über die erzielten
Ergebnisse, den Projektverlauf und die persönlichen Eindrücke der
Teilnehmer gegeben.

\section{Hintergrund des Projekts}

Schl"usselerfolgsfaktoren in der Softwaretechnik sind kurze
Time-to-market Zyklen, hohe Produktqualit"at und niedrige Kosten. Das Erzielen
dieser scheinbar unvereinbaren Ziele wird durch systematische
Wiederverwendung w"ahrend der Entwicklung von Software m"oglich.\par

Kernpunkt des Produktlinienansatzes ist die systematische Erfassung
von Unterschieden und Gemeinsamkeiten der verschiedenen Produkte und
einer expliziten Abbildung dieser Aspekte in die
Softwarearchitektur. Diese Grundidee hat Auswirkungen f"ur alle
Schritte im Produktentwicklungsprozess und - idealerweise - auch
dar"uber hinaus in der Produktplanung und -strategie.\par

Um eine effiziente Produktlinienentwicklung in der Softwareentwicklung
zu etablieren, ist es wichtig, dass diese Produktstrategie konsequent
umgesetzt wird.\par

Idealziel einer gut konfigurierten Produktlinie ist es, ein Produkt
durch einfache Kombination von angepassten Core-Assets zu
erstellen. Eine Produktlinie ist also ideal konfiguriert, wenn die
Produktlinien-Architektur für alle möglichen Produkte hinreichend
spezifiziert ist. Der Produkt\-linien-Ingenieur hat genau
diese Aufgabe. Er bestimmt die Architektur in dem er Core-Assets
definiert und deren Grundbeziehungen zueinander spezifiziert (Scoping
und Domain-Engineering). Soll nun ein neues Produkt in die
Produktlinie aufgenommen werden (Application Engineering), so muss es
dieser Architektur folgen. Es werden dazu bereits existierende
Varianten der Core-Assets mit neuen Varianten kombiniert und dem
Produkt-Ingenieur übergeben, der die Verantwortung für das Produkt
übernimmmt. Dieser hat dafür Sorge zu tragen, dass die Entwicklung an
dem Produkt nicht die Architektur der Produktlinie verletzt.\par 

In dieser Hierarchie ist es wichtig, dass bestimmte Vorgänge nach
festen Regeln kommuniziert werden. Wenn z.B. in einem Produkt eine
bereits existierende Variante eines Core-Assets verwendet wird, darf
diese nicht von dem Produkt-Entwickler verändert werden. Veränderungen
sind hier nur dem zuständigen Core-Asset-Entwickler gestattet. Dieser
muss abwägen, ob die Veränderung sinnvoll ist, da er die
Verantwortung für sein Modul, welches evtl. auch noch von anderen
Produkten verwendet wird, hat. Lehnt er dies ab, so muss der
Produkt-Ingenieur eine produktspezifische Variante dieses Core-Assets
entwickeln lassen. Dieser Vorgang ist sehr komplex, da mehrere Personen
mit ihren Entscheidungen daran beteiligt sind. Um eine Produktlinie
konsequent durchsetzen zu können, müssen diese Arbeitsabläufe
spezifiziert sein.\par

Es bietet sich nun an, die Entwicklung von Produktlinien mit Werkzeugen zu
unterstützen. Damit kann man sowohl das Configuration Managment
vereinfachen, sowie die oben erwähnten Arbeitsabläufe modellieren und damit
die Kommunikation und die Entwicklung erleichtern.

\section{Anforderungen}

Aus dem im vorherigen Abschnitt skizzierten Projekthintergrund ergaben
sich folgende Anforderungen im Detail, deren Umsetzung in einem
Angebotsdokument verbindlich mit dem Auftraggeber vereinbart wurden:

\begin{itemize}
	\item Produktlinie erstellen und bearbeiten vom Produktlinien-Ingenieur
	\item Produkt erstellen, bearbeiten und löschen
	\item graphische Darstellung von Produkt- und Produktlinienarchitekturen
	\item Vergleich der Produkt- und Produktlinienarchitekturen in Form eines Schnittgraphen
	\item Erfassung von Metadaten für jede Komponente und Beziehung
	\item Konsistenzchecks durchführen
	\item Erzeugung eines Überblick-Dokuments mit Metadaten und Abhängigkeiten
	\item Produkt-Ingenieure anlegen
	\item Verwaltung von Core Assets
	\item Produkt-Entwickler verwalten
	\item Produktlinien und Produkte nach Metadaten durchsuchen
	\item Auslösen von Workflows
	\item Repositories ansehen
	\item Arbeitsverzeichnis auschecken
	\item Arbeitsverzeichnis einchecken
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Projektergebnisse}

\section{Kobold}

Nach Abschluß der Entwicklungsarbeiten ist ein System etabliert, das, wie
ursprünglich geplant, drei ausführbare Anwendungen umfasst:\par

Der persistente Kobold-Server ermöglicht die zentrale Verwaltung von Produktlinien- 
und Benutzerdaten, sowie deren gegenseitigen Abhängigkeiten. Die im Server realisierten
Sicherheitsmechanismen erzwingen dabei die Durchsetzung der festgelegten Berechtigungen 
und stellen die Konsistenz des Produktlinien- und Benutzerdatenmodells sicher, selbst wenn
mit Hilfe der Clients der aktive Versuch der Sabotage unternommen wird.\par

Die Kommunikation zwischen Clients und Server erfolgt über eine verschlüsselte SSL-Verbindung.
Darüberhinaus können die Administartionsfunktionen des Servers durch ein zusätzliches Administartionspasswort
geschützt werden.\par

Die zweite ausführbare Anwendung des Kobold-Systems ist der User-Client. Über ihn können
sämtliche Aufgaben des Kobold-Systems mit Ausnahme von Administrationsmaßnahmen durchgeführt werden.
Der User-Client ist vollständig in die Eclipse-Plattform integriert und technisch von dieser
abhängig. Pro Instanz kann jeweils ein Benutzer am System arbeiten, der sich mittels Benutzernamen
und Kennwort am Server anmelden muss.\par

Die Benutzerschnittstelle ist dabei durchgehend defensiv ausgelegt, d.h. Funktionen des Clients sind nur 
dann anwählbar, wenn der jeweilige Benutzer dazu auch berechtigt ist und die jeweiligen Voraussetzungen dazu 
erfüllt sind (so kann beispielsweise der Produktlinieneditor erst gestartet werden, nachdem die Verbindung zum 
Server erfolgreich etabliert und die Berechtigung durch das System bestätigt wurde). Zusätzlich zu den serverseitigen
Sicherheitsmechanismen verhindert also bereits die clientseitige Benutzerschnittstelle die beabsichtigte oder unbeabsichtigte
Sabotage der Systemintegrität. Ferner wird dem Benutzer vom System selbst durch die Integration des
Handbuchs im Client zusätzliche Hilfestellung bei den alltäglichen Aufgaben bei der Arbeit mit Kobold geboten
(beachte dazu auch das Kapitel zum Handbuch).\par
 
Die dritte ausführbare Anwendung ist ein schlanker, text-basierter Client, der ausschließlich der Administartion
des Servers dient. Die User- und Administrations-Schnittstellen des Servers sind vollständig entkoppelt und die 
Clients selbst völlig unabhängig. Diese Aufteilung dient der Sicherheit der Systemintegrität. Trotz der extensiven 
Sicherheitsmechanismen stellen die Administartionsfunktionen des Kobold-Systems insofern ein Sicherheitsrisiko dar, 
als sie bei bewusster oder fahrlässiger Verwendung die Arbeit der Benutzer potentiell erschweren können.\par

Zu den Administartionsaufgaben gehören das Anlegen und Entfernen von Produktlinien, deren Zuordnung zu physischen 
VCM-Repositories, die Registrierung und datenkonsistenzwahrende Entfernung von Benutzern, sowie deren Zuordnung 
zu Produktlinien. Des weiteren können zahlreiche Informationen zu den auf dem jeweils administrierten Server
befindlichen Daten abgefragt werden.

% sollten wir das noch ausführlicher machen? sind halt viele Informationen in den anderen Kapiteln aufgeführt
% die wir ja nicht doppelt nennen sollten/müssen
 
\section{Dokumente}

Neben den zum System gehörenden Code-Dokumenten sind im Laufe des Projekts 
folgende Dokumente entstanden:

\subsection{Angebot}
\label{angebot}

In einem knapp 50-seitigen Angebot wurden die Anforderungen und ein
Projektablaufplan mit dem Auftraggeber vereinbart. Das Angebot
beinhaltete desweiteren eine Risikoanalyse und eine Beschreibung des
Prozessmodells und der geplanten Projektorganisation. In einem
angehängten Begriffslexikon wurden Begriffe der Problemdomäne
definiert, die zur Kommunikation mit dem Auftraggeber und innerhalb
des Teams verwendet wurden.

\subsection{Spezifikation}

Da Kobold mit einem iterativen Modell entwickelt wurde, wuchs auch die Spezifikation 
von Iteration zu Iteration an. Die Spezifikation I legte in ihren 35 Seiten zunächst 
einmal das Rahmengerüst von Kobold fest. In den darauffolgenden Iterationen wurden 
dann noch die fehlenden Use Cases spezifiziert und umgesetzt. Zum Schluss umfasste 
die Spezifikation von Kobold knapp 55 Seiten.

\subsection{Entwurf}

Nach Fertigstellung der ersten Spezifikation wurde ein umfassender Entwurf unter
Zuhilfenahme der grafischen Entwurfssprache UML erstellt. Dabei wurde - wenn
möglich - auf bekannte und bewährte Entwurfsmuster zurückgegriffen, unter anderem
auf das model-view-controller- und singelton-pattern.\par

Die Unterstützung der später verwendeten Programmiersprache Java für abstrakte
Klassenschnittstellen (Interfaces) wurde extensiv dazu verwendet, bei kritischen, vor
allem aber bei den Kommunikationsmodulen zwischen Server und Clients, eine günstige
Ausgangssituation für spätere Iterationen und Wartungsarbeiten zu schaffen. Dazu wurden
diese Schnittstellen bereits im ersten Entwurf sehr detailliert festgesetzt. Dieses
Vorgehen hat sich sehr gut bewährt.\par

Die Aufgaben für die Client- und Serveranwendungen wurden ebenfalls bereits im ersten
Entwurf klar aufgeteilt. Neben einer Serveranwendung wurden zwei Clientanwendungen
entworfen; eine zur Benutzung des Systems und eine davon unabhängige zur Administration
des Servers. Die dabei festgesetzte, strenge Aufgabenteilung wurde in den späteren
Iterationen mit lediglich marginalen Änderungen wie beschrieben umgesetzt.

\subsection{Handbuch}
\label{handbuch}

Dem Benutzer steht ein rund 120-seitiges mit Bildschirmfotos illustriertes
Handbuch zur Verfügung. Das Handbuch enthält einen Referenzteil, der
die Programmdialoge beschreibt und ein Tutorial, das dem
unerfahrenen Benutzer anhand eines Beispiels einen leichten Einstieg
in die Bedienung von Kobold ermöglicht.\par

Darüber hinaus wurde der Tutorial-Teil des Handbuchs in Form von Eclipse-Cheat-Sheets
direkt in den Userclient des Systems integriert, so dass dessen Benutzer die darin
enthaltenen Informationen direkt aus dem System heraus nutzen können ohne ihre
Arbeitsumgebung dazu verlassen zu müssen.

\subsection{Interne Dokumente}

Einige Dokumente wurden nur innerhalb des Teams verwendet und nicht an
den Auftraggeber ausgeliefert. Zu nennen sind hier ein Anforderungsdokument, 
Richtlinien zu Organisation und Qualitätssicherung sowie Testpläne und 
-berichte.\par

Dazu gehörten ferner die im Rahmen der Qualitätssicherungsmaßnahmen
erstellten Dokumente, konkret schriftliche Inspektionsfeedbacks, Einträge
im von der Berlios-Plattform bereitgestellten Bugtrackingsystem, sowie sämtliche
Walkthrough-, Review- und Beschlußfassungsprotokolle.

%\section{Weitere Ergebnisse}

%TODO! - bausteine? - howtos? - weiß nicht genau, wenn dir nichts einfällt,
% einfach weg damit - dito.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Projektorganisation}

\section{Projektrahmen}

Das Projekt wurde im Rahmen eines Studienprojkets A an der Universität Stuttgart
durchgeführt. Projekteigentümer war die Abteilung Programmiersprachen und Übersetzterbau
des Instituts für Softwaretechnologie.\par

Als Hilfestellung für die Projektmannschaft wurden begleitend zum Projekt selbst ein 
vom Projekteigentümer durchgeführtes Seminar zur Produktlinienentwicklung sowie eine
komplette Vorlesung zur Entwicklungstechnik des Reengineerings durchgeführt, an dem
alle Mitglieder der Projketmannschaft teilnahmen.\par

Aufgrund der für ein Studienprojekt untypisch hohen Verfügbarkeit an studentischen
Arbeitskräften wurde die zu entwickelnde Software parallel von zwei neunköpfigen
Entwicklerteams umgesetzt, die - soweit dies vom Projekteigentümer gestattet wurde -
trotzt der Konkurrenzsituation kooperieren und sich durch stetigen Erfahrungsaustausch 
gegenseitig motivieren konnten.

\section{Das Team}

Der zu diesem Bericht gehörige Auftragnehmer bestand aus einem der beiden
Entwicklerteams, nämlich demjenigen, welches unter dem Namen Werkbold firmierte.
Die zum Team gehörenden Studenten befanden sich zu Beginn des Projekts im fünften bzw. siebten Studiensemester. 

%TODO: Bild einfügen

\subsection{Rollen}

Auf die Vergabe von formalen Rollen wurden mangels Notwendigkeit
weitgehend verzichtet. Die Zuteilung der Aufgaben erfolgte
gemeinschaftlich, soweit möglich auf Basis freiwilliger Übernahme,
in jedem Fall aber unter Beachtung der persönlichen Fähigkeiten, 
während gemeinsamer Team-Treffen. Wäre eine Aufgabe von keinem der
Entwickler übernommen worden, so wäre diese vom Projektleiter zugeteilt
worden.


\subsubsection{Projektleiter}

Der Projektleiter vertrat die Interessen des Teams nach außen gegenüber 
dem Auftraggeber, koordinierte die Projektplanung, überwachte den
Entwicklungsfortschritt und förderte den Informationsaustausch im
Team und zum Auftraggeber. Die Rolle des Projektleiters wurde von
Anselm Garbe übernommen.

\subsubsection{Konfigurationsmanager}

Der Konfigurationsmanager setzte die
Entwicklungsumgebung auf und stellte die Verwaltung und
Versionierung von Dokumenten und des Source-Codes sicher. Die Rolle des
Konfigurationsmanagers wurde von Oliver Rendgen übernommen.

\subsubsection{Dokumentationsmanager}

Der Dokumentationsmanager war der
technischer Berater für alle Dokumente, die in der Entwicklung
enstanden. Er war für die Erstellung des Handbuchs verantwortlich.
Die Rolle des Dokumentationsmanager wurde von Frau Bettina Druckenmüller 
übernommen.

\subsubsection{QS-Manager}

Der QS-Manager war verantwortlich für die
generelle Organisation und Überwachung der
Qualitätssicherungsarbeiten (vgl. dynamische
Rolle "Qualitätssicherer"). Unter sein Aufgabenbereich fiel
insbesondere die Vermeidung von Widersprüchen bei den zu
erstellenden QS-Dokumenten und die Sicherstellung deren Einhaltung
durch das Team. Die Rolle des QS-Manager wurde von Armin Cont übernommen.

\subsubsection{Entwickler}

Die Aufgabe der Entwickler war die Erstellung des Quellcodes und das
Verfassen der Dokumente. Die Rolle der Entwickler wurde von allen
Teilnehmern belegt.

\section{Schulungen}

Aufgrund der unterschiedlichen Vorkenntnisse der einzelnen Teammitglieder
wurde der naheligende Versuch unternommen, zumindest die gröbsten Unterschiede
durch Schulungen auszugleichen, um ein gemeinsames Knowhow-Level für die weitere
Zusammenarbeit im Team zu erreichen.\par

Die Schulungen wurden dabei von einem oder zwei Teammitgliedern durchgeführt, die
in dem jeweiligen Themenbereichen besonders qualifiziert bzw. erfahren waren. Die
Durchführung der Schulungen erfolgte standardisiert unter Zuhilfenahme von durch
die Referenten vorbereiteten Schulungsmaterialien (Folien, Fallbeispiele, Übungen etc.) 
mit abschließender schriftlicher Ausarbeitung, wenn dies von den Geschulten bzw. den
Referenten im jeweiligen Fall für notwendig erachtet wurde.\par

Nach den Schulungen waren die Referenten die ersten Ansprechpartner für Probleme, die
den behandelten Themenbereichen zugeordnet werden konnten.\par

In den durchgeführten Schulungen wurde ein breites Spektrum unterschiedlicher Themenbereiche
abgedeckt, vom Umgang mit einzelnen Werkzeugen, über Entwurfstechniken, bis hin zu den
eingesetzten Entwicklungs- und Dokumentationssprachen.

% bitte hilf mir, habe nicht alle Schulungen besucht...

%TODO! Bettina


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Projektablauf}

\section{Prozessmodell}

Es wurde ein evolutionäres Vorgehensmodell\footnote{Vgl. Literatur, u.a. J.
Ludewig, Sammlung von Kapiteln zum Software Engineering} angewendet, das sich
in mehrere Iterationen unterteilte. Jede Iteration entsprach dem
Wasserfall-Vorgehensmodell. Das Vorgehensmodell ähnelt dem Spiralmodell nach
B.W. Boehm.
Durch die Anwendung dieses Vorgehensmodells ergaben sich folgende Vorteile:

\begin{itemize}
\item Der Umfang der iterativen Spezifikationen und Entwürfe war wesentlich
kleiner als bei einer Wasserfall-Gesamtentwicklung. Der inkrementelle Umfang
resultierte in einer geringeren Fehleranfälligkeit und garantierte somit einen
höheren Qualitätsstandard.
\item Der Entwicklungsfortschritt konnte somit vom Auftraggeber und vom
Entwicklungsteam realistischer eingeschätzt werden, da regelmäßig
eine neue Auslieferung durchgeführt wurde, die vom Auftraggeber abgenommen
werden musste.
\item Durch die Wahl der {\it J2SE} Technologie fand die Entwicklung
nach modernen {\it Design Patterns}\footnote{Vgl. Literatur, Design
Patterns, Erich Gamma} und objektorientierten Paradigmen statt. Im Gegensatz zu
imperativen Technologien wurde dadurch eine geringere Kopplung der
Software-Komponenten und somit eine bessere Zerlegung des Systems erreicht.
Eine derart leicht durchführbare Zerlegung des Systems nach funktionalen
Bestandteilen ermöglichte besonders das evolutionäre Vorgehen.
\item Es konnten neue oder geänderte Anforderungen in einer späteren Iteration
wesentlich flexibler im Entwicklunsprozess berücksichtigt und realisiert
werden.
\end{itemize}

Ein entscheidener Unterschied zu konventionellen Vorgehensmodellen war der
höhere Kommunikationsaufwand zwischen dem Auftraggeber und dem Entwicklerteam.
Dieser höhere Kommunikationsaufwand zeichnete sich in jedem Fall positiv für den
Auftraggeber aus, da Anforderungen schon aufgrund der Quantität der
Kommunikation besser einfliessen konnten. Außerdem hatte der Auftraggeber die
Möglichkeit, nach jeder abgeschlossenen Iteration, auch größere Änderungswünsche
einzubringen. \par


\section{Projektplan}

Bereits Während des Vorprojekts wurde ein grober Plan für das Gesamtprojekt erstellt,
der Bestandteil des Angebots wurde. Dieser grobe Projektplan wurde zu Beginn der
ersten Iteration gründlich überarbeitet und sehr detailiert festgelegt.\par

Da dem Kunden nach Abschluß jeder Iteartion die Möglichkeit gegeben wurde, aktiv auf
die Entwicklung Einfluß zu nehmen und dieser davon auch mit offensichtlicher
Begeisterung Gebrauch machte, wurde der ursprüngliche Projektplan zu Beginn jeder neuen
Iteration an die vom Kunden neu geschaffenen Realitäten angepasst.

\section{Arbeitszeitverteilung}

%TODO! siehe Duck

\section{Werkzeuge}

Die im Rahmen des Projekts eingesetzten Werkzeuge lassen sich grob in drei Kategorien
einteilen:\par

Als Kommunikationswerkzeuge wurden hauptsächlich verschiedene Emailsysteme und 
Mobilfunktelefone eingesetzt. Das Gros der im Rahmen des Projekts versendeten
Emails lief über zwei eigens für dieses Projekt eingerichtete Verteilerlisten,
eine Team-interne und eine das Team und den Projekteigentümer umfassende.\par

Zur Erstellung von nicht-Code-Dokumenten aller Art wurde die Dokumentenerzeugungssprache
Tech eingesetzt sowie der UML-Diagrammer ArgoUML für Entwurfsdokumente. In einigen
Ausnahmefällen wurden das Präsentationswerkzeug Powerpoint (für einige Schulungen) sowie
diverse einfache Texteditoren eingesetzt.\par

Zur Erstellung von Codedokumenten wurden die Editoren der integrierten Java Entwicklungsumgebung 
der Eclipse-Plattform eingesetzt. Sämtliche Dokumente wurden über ein zentrales CVS-Repository 
verwaltet, welches vom Fraunhofer Institut über die Berlios-Plattform zur Verfügung gestellt wurde.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Statistische Analyse}


\section{Quellcodeumfang}

\begin{figure}[h!]
  \centering
  \includegraphics[width=15cm]{praesentation/lines_of_code}
  \caption{Quellcode Zeilenanzahl über die Zeit}
\end{figure}

Das Diagramm zeigt die gesammte Zeilenanzahl des Quellcodes inklusive
aller Kommentarzeilen über die Laufzeit des Projekts. Die vertikalen
gestrichelten Linien geben die Versionsmarkierungen an, zu diesem
Zeitpunkt wurde jeweils eine lauffähige POA Version an den
Auftraggeber ausgeliefert.\par

An dem Diagramm lassen sich auch die Iterationen ablesen. Dabei stehen die 
Markierungen mit der Bezeichnung PP für einen jeweils neuen Projektplan und
somit für eine neue Itertion. Die End-Deploy Markierungen zum Ende des Projektes
stehen für einen weiteren Übergang in eine verkürzte Itertion, in der nur noch
implementiert und getestet wurde.\par

Es ist deutlich zu sehen, wie die Anzahl der Codezeilen nach Abschluss des ersten
Entwurfes (Markierung E 1-0) rapide zu steigen beginnt. Die drei flachen Sektoren im August, September und Oktober zeigen deutlich die
Prüfungszeit, in der die Mehrzahl der Team-Mitglieder ausfiehl. 


\section{Umfang der Module}

\begin{figure}[h!]
  \centering
  \includegraphics[width=15cm]{praesentation/modulgroessen}
  \caption{Umfang der Module in Codezeilen}
\end{figure}

Dieses Diagramm zeigt Größenverhältnisse der Module, gemessen in
Quellcodezeilen. Dabei fällt das PLAM-Modul besonders groß aus, da sich
in diesem Modul die gesamte GUI-Implementierung befindet. Die Größen der
VCM, Common und Server-Module spiegeln in keinem Fall den Aufwand wieder.\par

Die Daten des Tests befinden sich in dem Modul "other". Allerdings ist zu
berücksichtigen, dass die meisten Testdaten dort nicht inbegriffen sind und
der automatisierte Test in den Modulen des jeweils zu testenden Teiles enthalten
sind. 


\section{Aufwand für die einzelnen Phasen}

\begin{figure}[h!]
  \centering
  \includegraphics[width=15cm]{praesentation/aufwand_pro_phase}
  \caption{Aufwand pro Phase gemessen in Arbeitszeit}
\end{figure}

Das Diagramm zeigt den prozentuellen Anteil der Arbeitszeit, die für die einzelnen
Phasen aufgebracht wurde. Besonders auffällig ist der große Anteil der Implementierung
mit über 60 Prozent. Im Vergleich dazu sind die Phasen Spezifikation und Entwurf 
sehr kurz gehalten. Möglicherweise ist deshalb der Aufwand für die Implementierung 
so groß ausgefallen. Aufgrund dessen ist bedauerlicherweise auch der Anteil am 
Test relativ gering. Dies liegt mitunter daran, dass erst spät mit dem offiziellen Test
begonnen wurde und größere Fehler im Programm oft einen Test vorzeitig beendeten.


\section{Entwicklerkooperation}
\label{developer by file}

%TODO! Bettina


\section{Arbeitzeit}

\begin{figure}[h!]
  \centering
  \includegraphics[width=15cm]{praesentation/commit_by_hour}
  \caption{Uhrzeiten der CVS Repository Aktivität}
\end{figure}

Das Diagramm zeigt die Uhrzeiten der Aktivitäten im Quellcode
Repository. Eine höhere Anzahl Commits bedeutet eine höhere
Aktivität. Typisch ist die erhöhte Aktivität zwischen 13 und 19 Uhr,
die auch bei anderen Studienprojekten zu beobachten
ist. Offensichtlich ist das eine übliche Zeit das Arbeitsergebnis z.B.
zum Ende der Kernarbeitszeit in das Repository zu
comitten. Bemerkenswert sind die Aktivitäten nach 22 Uhr, die bis in
die Morgenstunden reichen. Es gibt eine ausgeprägte
Bandbreite von bevorzugten Arbeitszeiten wobei die Arbeiter am Nachmittag
eindeutig die Mehrheit im Team stellen. 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Persönliche Berichte}

%TODO! -> alle!

\section{Michael Grosse}

%TODO: Bild einfügen

\subsection{Tätigkeiten}
Das Studienprojekt A - Kobold war für mich das erste Softwareprojekt in
dieser Größenordnung. Da einige in unserem Projektteam das Studienprojekt B
vorgezogen hatten, hatte ich vor allem am Anfang noch recht wenig Erfahrung
im Umgang mit vielen Projektteilnehmern.
Meinte Tätigkeiten lassen sich am besten in die Tätigkeiten des Vorprojekts
und des Hauptprojektes untergliedern. Während des Vorprojektes nahm ich, wie
alle anderen, an allen Analysegeprächen mit den Kunden teil und erstellte
mit meinen anderen Teammitgliedern zusammen hieraus einen groben Entwurf
sowie das daraus resultierende Angebot.
Im Hauptprojekt war ich zunächst an der Erstellung des Grobentwurfs
beteiligt. Für das interne Seminar bereitete ich das Thema Design Patterns
zusammen mit Armin Cont vor.
Nachdem die wichtigsten internen Schulungen gehalten waren, stand die
Einarbeitung in Java und hier speziell in die recht komplexe Struktur von
Eclipse an. Aufgrund meiner früheren Programmiererfahrung stellte Java an
sich kaum ein Problem dar. Die von uns gewählte Eclipse Plattform jedoch ein
umso größeres. Meine erste Aufgabe innerhalb der Programmierung war die
Entwicklung einer Übersicht für unsere Workflowmeldungen.
Hierfür musste zuerst einmal herausgefunden werden, welche der vielen von
Eclipse zur Verfügung gestellten Darstellungsmöglichkeiten für das Projekt
am sinnvollsten verwendet werden könnte. Aufgrund der, wie sich
herausstellte, großen Komplexität dieser Aufgabe, bearbeitete ich diese
Aufgabe zusammen mit Martin Plies.
Nachdem diese Aufgabe erfolgreich zuende gebracht war, wurde mir
aufgetragen, zusammen mit Bettina Druckenmüller die Erstellung der Workflows
zu entwickeln. Bei dieser Aufgabe war ich allerdings nur in den
Anfangsphasen dabei.
Danach wurde mir aufgetragen, alle Benutzersteuerungsdialoge, wie Benutzer
anlegen, Benutzernamen ändern und Benutzer löschen zu erstellen. Diese
Aufgabe fiel mir recht leicht, da ich mich an der Struktur schon bestehender
ähnlicher Dialoge recht gut orientieren konnte.
Mit zunehmendem Projektverlauf bekam die Qualitätssicherung einen größeren
Stellenwert, so dass ich bei Reviews und den einsetzenden Tests zunehmend
eingesetzt wurde. Außerdem betreute ich die Testdurchführung unseres
Partnerteams.
Bei den Abschlusstests lag meine Aufgabe darin, diese Tests zu organisieren
und durchzuführen, sowie danach die entstandenen Fehlermeldungen in unseren
Bugtracker einzutragen. 
Zum Abschluss des Projektes wirkte ich noch an der Erstellung der
Abschlusspräsentation mit.

\subsection{Beurteilung}
Alles in allem gesehen würde ich sagen, dass Kobold ein perfektes Projekt
zum Lernen war. Aufgrund der sehr komplexen eingesetzten Technik, welche
ursprünglich völlig unterschätzt worden war kamen unsere Zeitpläne
regelmässig durcheinander.
Das von uns gewählte evolutionäre Entwicklungsmodell zeigte in diesem
Projekt seine Risiken, was mir persönlich zeigte, wie wichtig die
Qualitätssicherung innerhalb eines Projektes ist.
Für mich persönlich ergab sich ein recht tiefer Einblick in die Dynamiken
einer größeren Gruppe. Auch lernte ich, wie wichtig eine frühzeitige und vor
allem durchgängige Qualitätssicherung für das Wohl und Wehe eines Projektes
ist. 
Was mich positiv überrascht hatte war zum einen der Große Zusammenhalt
innerhalb der Gruppe, wie auch die gute Zusammenarbeit mit unserem
"Konkurrenzteam".
Der Lernerfolg dieses Projektes lässt sich in folgende Stichwörter fassen:
Das evolutionäre Entwicklungsmodell, Eclipse als Plattform und der
Stellenwert der Qualitätssicherung.





\appendix

\chapter{Erklärung gemäß Prüfungsordnung}

Ich erkläre hiermit, dass ich im Rahmen meiner Mitarbeit am
Studienprojekt A ``Produktlinien'' außer von den
Betreuern vorgesehenen bzw. genehmigten Hilfsmitteln keine unzulässige
Hilfe in Anspruch genommen habe.

\vspace{2cm}
Stuttgart, den 25. Oktober 2004
\vspace{2cm}

\begin{center}
\begin{tabular}{ccc}
  \hspace{5cm} & \hspace{5cm} & \hspace{5cm} \\
  \hhline{-~-} Necati Aydin & & Anselm Garbe \\
  \vspace{1,5cm} \\
  \hhline{-~-} Michael Grosse & & Martin Plies \\
  \vspace{1,5cm} \\
  \hhline{-~-} Oliver Rendgen & & Patrick Schneider \\
    \vspace{1,5cm} \\
  \hhline{-~-} Armin Cont & & Bettina Druckenmüller \\
  \vspace{1,5cm} \\
  \hhline{-~~} Tammo van Lessen \\
\end{tabular}
\end{center}

\end{document}
