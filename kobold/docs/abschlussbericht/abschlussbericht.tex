\documentclass[a4paper,titlepage,12pt,ngerman]{scrbook}
\usepackage{../common/header}
\RequirePackage{hhline}

\RCSdef $Revision: 1.0 $
\RCSdef $Date: 2004/10/25 $

\newcommand\version{Version 1.0 \xspace}

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Deckblatt

\begin{titlepage}
\renewcommand{\thefootnote}{\fnsymbol{footnote}}
{\Huge
\raggedright
\textbf{\bf Kobold} \\
\huge Product Line Management System
\rule{\textwidth}{0.75pt}
\par
}
\begin{flushleft}
\normalsize
\version
\end{flushleft}


\vfill
\includegraphics[width=15cm]{../common/logo-color.png}
\vfill
{\parindent=0cm
\Huge Abschlussbericht
}


\setcounter{footnote}{0}
\end{titlepage}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Versionsgeschichte

\section*{Versionsgeschichte}

\begin{itemize}

\item Version 1.0 

\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Inhaltsverzeichnis

\tableofcontents

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Einleitung}

\section{Zweck des Dokuments}

Dieses Dokument beschreibt das Projekt ``Produktlinien'', das von Anfang Oktober
 2003 bis Anfang November 2004 an der
Universitï¿½t Stuttgart am Institut fï¿½r Softwaretechnologie (ISTE) durchgefï¿½hrt
wurde. Das Projekt wurde von neun Softwaretechnik Studenten - Necati
Aydin, Anselm Garbe, Tammo van Lessen, Michael Grosse, Armin Cont, Patrick Schneider,
Oliver Rendgen, Martin Plies und Bettina Druckenmï¿½ller - im Rahmen eines Studienprojekts A
durchgefï¿½hrt. Im Folgenden wird ein ï¿½berblick ï¿½ber die erzielten
Ergebnisse, den Projektverlauf und die persï¿½nlichen Eindrï¿½cke der
Teilnehmer gegeben.

\section{Hintergrund des Projekts}

Schl"usselerfolgsfaktoren in der Softwaretechnik sind kurze
Time-to-market Zyklen, hohe Produktqualit"at und niedrige Kosten. Das Erzielen
dieser scheinbar unvereinbaren Ziele wird durch systematische
Wiederverwendung w"ahrend der Entwicklung von Software m"oglich.\par

Kernpunkt des Produktlinienansatzes ist die systematische Erfassung
von Unterschieden und Gemeinsamkeiten der verschiedenen Produkte und
einer expliziten Abbildung dieser Aspekte in die
Softwarearchitektur. Diese Grundidee hat Auswirkungen f"ur alle
Schritte im Produktentwicklungsprozess und - idealerweise - auch
dar"uber hinaus in der Produktplanung und -strategie.\par

Um eine effiziente Produktlinienentwicklung in der Softwareentwicklung
zu etablieren, ist es wichtig, dass diese Produktstrategie konsequent
umgesetzt wird.\par

Idealziel einer gut konfigurierten Produktlinie ist es, ein Produkt
durch einfache Kombination von angepassten Core-Assets zu
erstellen. Eine Produktlinie ist also ideal konfiguriert, wenn die
Produktlinien-Architektur fï¿½r alle mï¿½glichen Produkte hinreichend
spezifiziert ist. Der Produkt\-linien-Ingenieur hat genau
diese Aufgabe. Er bestimmt die Architektur in dem er Core-Assets
definiert und deren Grundbeziehungen zueinander spezifiziert (Scoping
und Domain-Engineering). Soll nun ein neues Produkt in die
Produktlinie aufgenommen werden (Application Engineering), so muss es
dieser Architektur folgen. Es werden dazu bereits existierende
Varianten der Core-Assets mit neuen Varianten kombiniert und dem
Produkt-Ingenieur ï¿½bergeben, der die Verantwortung fï¿½r das Produkt
ï¿½bernimmmt. Dieser hat dafï¿½r Sorge zu tragen, dass die Entwicklung an
dem Produkt nicht die Architektur der Produktlinie verletzt.\par 

In dieser Hierarchie ist es wichtig, dass bestimmte Vorgï¿½nge nach
festen Regeln kommuniziert werden. Wenn z.B. in einem Produkt eine
bereits existierende Variante eines Core-Assets verwendet wird, darf
diese nicht von dem Produkt-Entwickler verï¿½ndert werden. Verï¿½nderungen
sind hier nur dem zustï¿½ndigen Core-Asset-Entwickler gestattet. Dieser
muss abwï¿½gen, ob die Verï¿½nderung sinnvoll ist, da er die
Verantwortung fï¿½r sein Modul, welches evtl. auch noch von anderen
Produkten verwendet wird, hat. Lehnt er dies ab, so muss der
Produkt-Ingenieur eine produktspezifische Variante dieses Core-Assets
entwickeln lassen. Dieser Vorgang ist sehr komplex, da mehrere Personen
mit ihren Entscheidungen daran beteiligt sind. Um eine Produktlinie
konsequent durchsetzen zu kï¿½nnen, mï¿½ssen diese Arbeitsablï¿½ufe
spezifiziert sein.\par

Es bietet sich nun an, die Entwicklung von Produktlinien mit Werkzeugen zu
unterstï¿½tzen. Damit kann man sowohl das Configuration Managment
vereinfachen, sowie die oben erwï¿½hnten Arbeitsablï¿½ufe modellieren und damit
die Kommunikation und die Entwicklung erleichtern.

\section{Anforderungen}

Aus dem im vorherigen Abschnitt skizzierten Projekthintergrund ergaben
sich folgende Anforderungen im Detail, deren Umsetzung in einem
Angebotsdokument verbindlich mit dem Auftraggeber vereinbart wurden:

\begin{itemize}
	\item Produktlinie erstellen und bearbeiten vom Produktlinien-Ingenieur
	\item Produkt erstellen, bearbeiten und lï¿½schen
	\item graphische Darstellung von Produkt- und Produktlinienarchitekturen
	\item Vergleich der Produkt- und Produktlinienarchitekturen in Form eines Schnittgraphen
	\item Erfassung von Metadaten fï¿½r jede Komponente und Beziehung
	\item Konsistenzchecks durchfï¿½hren
	\item Erzeugung eines ï¿½berblick-Dokuments mit Metadaten und Abhï¿½ngigkeiten
	\item Produkt-Ingenieure anlegen
	\item Verwaltung von Core Assets
	\item Produkt-Entwickler verwalten
	\item Produktlinien und Produkte nach Metadaten durchsuchen
	\item Auslï¿½sen von Workflows
	\item Repositories ansehen
	\item Arbeitsverzeichnis auschecken
	\item Arbeitsverzeichnis einchecken
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Projektergebnisse}

\section{Kobold}

Nach Abschluï¿½ der Entwicklungsarbeiten ist ein System etabliert, das, wie
ursprï¿½nglich geplant, drei ausfï¿½hrbare Anwendungen umfasst:\par

Der persistente Kobold-Server ermï¿½glicht die zentrale Verwaltung von Produktlinien- 
und Benutzerdaten, sowie deren gegenseitigen Abhï¿½ngigkeiten. Die im Server realisierten
Sicherheitsmechanismen erzwingen dabei die Durchsetzung der festgelegten Berechtigungen 
und stellen die Konsistenz des Produktlinien- und Benutzerdatenmodells sicher, selbst wenn
mit Hilfe der Clients der aktive Versuch der Sabotage unternommen wird.\par

Die Kommunikation zwischen Clients und Server erfolgt ï¿½ber eine verschlï¿½sselte SSL-Verbindung.
Darï¿½berhinaus kï¿½nnen die Administartionsfunktionen des Servers durch ein zusï¿½tzliches Administartionspasswort
geschï¿½tzt werden.\par

Die zweite ausfï¿½hrbare Anwendung des Kobold-Systems ist der User-Client. ï¿½ber ihn kï¿½nnen
sï¿½mtliche Aufgaben des Kobold-Systems mit Ausnahme von Administrationsmaï¿½nahmen durchgefï¿½hrt werden.
Der User-Client ist vollstï¿½ndig in die Eclipse-Plattform integriert und technisch von dieser
abhï¿½ngig. Pro Instanz kann jeweils ein Benutzer am System arbeiten, der sich mittels Benutzernamen
und Kennwort am Server anmelden muss.\par

Die Benutzerschnittstelle ist dabei durchgehend defensiv ausgelegt, d.h. Funktionen des Clients sind nur 
dann anwï¿½hlbar, wenn der jeweilige Benutzer dazu auch berechtigt ist und die jeweiligen Voraussetzungen dazu 
erfï¿½llt sind (so kann beispielsweise der Produktlinieneditor erst gestartet werden, nachdem die Verbindung zum 
Server erfolgreich etabliert und die Berechtigung durch das System bestï¿½tigt wurde). Zusï¿½tzlich zu den serverseitigen
Sicherheitsmechanismen verhindert also bereits die clientseitige Benutzerschnittstelle die beabsichtigte oder unbeabsichtigte
Sabotage der Systemintegritï¿½t. Ferner wird dem Benutzer vom System selbst durch die Integration des
Handbuchs im Client zusï¿½tzliche Hilfestellung bei den alltï¿½glichen Aufgaben bei der Arbeit mit Kobold geboten
(beachte dazu auch das Kapitel zum Handbuch).\par
 
Die dritte ausfï¿½hrbare Anwendung ist ein schlanker, text-basierter Client, der ausschlieï¿½lich der Administartion
des Servers dient. Die User- und Administrations-Schnittstellen des Servers sind vollstï¿½ndig entkoppelt und die 
Clients selbst vï¿½llig unabhï¿½ngig. Diese Aufteilung dient der Sicherheit der Systemintegritï¿½t. Trotz der extensiven 
Sicherheitsmechanismen stellen die Administartionsfunktionen des Kobold-Systems insofern ein Sicherheitsrisiko dar, 
als sie bei bewusster oder fahrlï¿½ssiger Verwendung die Arbeit der Benutzer potentiell erschweren kï¿½nnen.\par

Zu den Administartionsaufgaben gehï¿½ren das Anlegen und Entfernen von Produktlinien, deren Zuordnung zu physischen 
VCM-Repositories, die Registrierung und datenkonsistenzwahrende Entfernung von Benutzern, sowie deren Zuordnung 
zu Produktlinien. Des weiteren kï¿½nnen zahlreiche Informationen zu den auf dem jeweils administrierten Server
befindlichen Daten abgefragt werden.

% sollten wir das noch ausfï¿½hrlicher machen? sind halt viele Informationen in den anderen Kapiteln aufgefï¿½hrt
% die wir ja nicht doppelt nennen sollten/mï¿½ssen - ich finde, es reicht so; mal sehen, was die anderen beim
% Review sagen
 
\section{Dokumente}

Neben den zum System gehï¿½renden Code-Dokumenten sind im Laufe des Projekts 
folgende Dokumente entstanden:

\subsection{Angebot}
\label{angebot}

In einem knapp 50-seitigen Angebot wurden die Anforderungen und ein
Projektablaufplan mit dem Auftraggeber vereinbart. Das Angebot
beinhaltet desweiteren eine Risikoanalyse und eine Beschreibung des
Prozessmodells und der geplanten Projektorganisation. In einem
angehï¿½ngten Begriffslexikon werden Begriffe der Problemdomï¿½ne
definiert, die zur Kommunikation mit dem Auftraggeber und innerhalb
des Teams verwendet wurden.

\subsection{Spezifikation}

Da Kobold mit einem iterativen Modell entwickelt wurde, wuchs auch die Spezifikation 
von Iteration zu Iteration an. Die Spezifikation I legte in ihren 35 Seiten zunï¿½chst 
einmal das Rahmengerï¿½st von Kobold fest. In den darauffolgenden Iterationen wurden 
dann noch die fehlenden Use Cases spezifiziert und umgesetzt. Zum Schluss umfasste 
die Spezifikation von Kobold knapp 55 Seiten.

\subsection{Entwurf}

Nach Fertigstellung der ersten Spezifikation wurde ein umfassender Entwurf unter
Zuhilfenahme der grafischen Entwurfssprache UML erstellt. Dabei wurde - wenn
mï¿½glich - auf bekannte und bewï¿½hrte Entwurfsmuster zurï¿½ckgegriffen, unter anderem
auf das model-view-controller- und singelton-pattern.\par

Die Unterstï¿½tzung der spï¿½ter verwendeten Programmiersprache Java fï¿½r abstrakte
Klassenschnittstellen (Interfaces) wurde extensiv dazu verwendet, bei kritischen, vor
allem aber bei den Kommunikationsmodulen zwischen Server und Clients, eine gï¿½nstige
Ausgangssituation fï¿½r spï¿½tere Iterationen und Wartungsarbeiten zu schaffen. Dazu wurden
diese Schnittstellen bereits im ersten Entwurf sehr detailliert festgesetzt. Dieses
Vorgehen hat sich sehr gut bewï¿½hrt.\par

Die Aufgaben fï¿½r die Client- und Serveranwendungen wurden ebenfalls bereits im ersten
Entwurf klar aufgeteilt. Neben einer Serveranwendung wurden zwei Clientanwendungen
entworfen; eine zur Benutzung des Systems und eine davon unabhï¿½ngige zur Administration
des Servers. Die dabei festgesetzte, strenge Aufgabenteilung wurde in den spï¿½teren
Iterationen mit lediglich marginalen ï¿½nderungen wie beschrieben umgesetzt.

\subsection{Handbuch}
\label{handbuch}

Dem Benutzer steht ein rund 120-seitiges mit Bildschirmfotos illustriertes
Handbuch zur Verfï¿½gung. Das Handbuch enthï¿½lt einen Referenzteil, der
die Programmdialoge beschreibt und ein Tutorial, das dem
unerfahrenen Benutzer anhand eines Beispiels einen leichten Einstieg
in die Bedienung von Kobold ermï¿½glicht.\par

Darï¿½ber hinaus wurde der Tutorial-Teil des Handbuchs in Form von Eclipse-Cheat-Sheets
direkt in den Userclient des Systems integriert, so dass dessen Benutzer die darin
enthaltenen Informationen direkt aus dem System heraus nutzen kï¿½nnen ohne ihre
Arbeitsumgebung dazu verlassen zu mï¿½ssen.

\subsection{Interne Dokumente}

Einige Dokumente wurden nur innerhalb des Teams verwendet und nicht an
den Auftraggeber ausgeliefert. Zu nennen sind hier ein Anforderungsdokument, 
Richtlinien zu Organisation und Qualitï¿½tssicherung sowie Testplï¿½ne und 
-berichte.\par

Dazu gehï¿½rten ferner die im Rahmen der Qualitï¿½tssicherungsmaï¿½nahmen
erstellten Dokumente, konkret schriftliche Inspektionsfeedbacks, Eintrï¿½ge
im von der Berlios-Plattform bereitgestellten Bugtrackingsystem, sowie sï¿½mtliche
Walkthrough-, Review- und Beschluï¿½fassungsprotokolle.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Projektorganisation}

\section{Projektrahmen}

Das Projekt wurde im Rahmen eines Studienprojkets A an der Universitï¿½t Stuttgart
durchgefï¿½hrt. Projekteigentï¿½mer war die Abteilung Programmiersprachen und ï¿½bersetzterbau
des Instituts fï¿½r Softwaretechnologie.\par

Als Hilfestellung fï¿½r die Projektmannschaft wurden begleitend zum Projekt selbst ein 
vom Projekteigentï¿½mer durchgefï¿½hrtes Seminar zur Produktlinienentwicklung sowie eine
komplette Vorlesung zur Entwicklungstechnik des Reengineerings durchgefï¿½hrt, an dem
alle Mitglieder der Projketmannschaft teilnahmen.\par

Aufgrund der fï¿½r ein Studienprojekt untypisch hohen Verfï¿½gbarkeit an studentischen
Arbeitskrï¿½ften wurde die zu entwickelnde Software parallel von zwei neunkï¿½pfigen
Entwicklerteams umgesetzt, die - soweit dies vom Projekteigentï¿½mer gestattet wurde -
trotzt der Konkurrenzsituation kooperieren und sich durch stetigen Erfahrungsaustausch 
gegenseitig motivieren konnten.

\section{Das Team}

Der zu diesem Bericht gehï¿½rige Auftragnehmer bestand aus einem der beiden
Entwicklerteams, nï¿½mlich demjenigen, welches unter dem Namen Werkbold firmierte.
Die zum Team gehï¿½renden Studenten befanden sich zu Beginn des Projekts im fï¿½nften bzw. siebten Studiensemester. 

%TODO: Bild einfï¿½gen

\subsection{Rollen}

Auf die Vergabe von formalen Rollen wurden weitgehend verzichtet. 
Die Zuteilung der Aufgaben erfolgte
gemeinschaftlich, soweit mï¿½glich auf Basis freiwilliger ï¿½bernahme,
in jedem Fall aber unter Beachtung der persï¿½nlichen Fï¿½higkeiten, 
wï¿½hrend gemeinsamer Team-Treffen. Wurde eine Aufgabe von keinem der
Entwickler ï¿½bernommen, so wurde diese vom Projektleiter zugeteilt.


\subsubsection{Projektleiter}

Der Projektleiter vertrat die Interessen des Teams nach auï¿½en gegenï¿½ber 
dem Auftraggeber, koordinierte die Projektplanung, ï¿½berwachte den
Entwicklungsfortschritt und fï¿½rderte den Informationsaustausch im
Team und zum Auftraggeber. Die Rolle des Projektleiters wurde von
Anselm Garbe ï¿½bernommen.

\subsubsection{Konfigurationsmanager}

Der Konfigurationsmanager setzte die
Entwicklungsumgebung auf und stellte die Verwaltung und
Versionierung von Dokumenten und des Source-Codes sicher. Die Rolle des
Konfigurationsmanagers wurde von Oliver Rendgen ï¿½bernommen.

\subsubsection{Dokumentationsmanager}

Der Dokumentationsmanager war der
technischer Berater fï¿½r alle Dokumente, die in der Entwicklung
enstanden. Er war fï¿½r die Erstellung des Handbuchs verantwortlich.
Die Rolle des Dokumentationsmanager wurde von Frau Bettina Druckenmï¿½ller 
ï¿½bernommen.

\subsubsection{QS-Manager}

Der QS-Manager war verantwortlich fï¿½r die
generelle Organisation und ï¿½berwachung der
Qualitï¿½tssicherungsarbeiten (vgl. dynamische
Rolle "Qualitï¿½tssicherer"). Unter sein Aufgabenbereich fiel
insbesondere die Vermeidung von Widersprï¿½chen bei den zu
erstellenden QS-Dokumenten und die Sicherstellung deren Einhaltung
durch das Team. Die Rolle des QS-Manager wurde von Armin Cont ï¿½bernommen.

\subsubsection{Entwickler}

Die Aufgabe der Entwickler war die Erstellung des Quellcodes und das
Verfassen der Dokumente. Die Rolle der Entwickler wurde von allen
Teilnehmern belegt.

\section{Schulungen}

Aufgrund der unterschiedlichen Vorkenntnisse der einzelnen Teammitglieder
wurde der naheligende Versuch unternommen, zumindest die grï¿½bsten Unterschiede
durch Schulungen auszugleichen, um ein gemeinsames Knowhow-Level fï¿½r die weitere
Zusammenarbeit im Team zu erreichen.\par

Die Schulungen wurden dabei von einem oder zwei Teammitgliedern durchgefï¿½hrt, die
in dem jeweiligen Themenbereichen besonders qualifiziert bzw. erfahren waren. Die
Durchfï¿½hrung der Schulungen erfolgte standardisiert unter Zuhilfenahme von durch
die Referenten vorbereiteten Schulungsmaterialien (Folien, Fallbeispiele, ï¿½bungen etc.) 
mit abschlieï¿½ender schriftlicher Ausarbeitung, wenn dies von den Geschulten bzw. den
Referenten im jeweiligen Fall fï¿½r notwendig erachtet wurde.\par

Nach den Schulungen waren die Referenten die ersten Ansprechpartner fï¿½r Probleme, die
den behandelten Themenbereichen zugeordnet werden konnten.\par

In den durchgefï¿½hrten Schulungen wurde ein breites Spektrum unterschiedlicher Themenbereiche
abgedeckt, vom Umgang mit einzelnen Werkzeugen, ï¿½ber Entwurfstechniken, bis hin zu den
eingesetzten Entwicklungs- und Dokumentationssprachen:

\begin{itemize}
	\item 02.02.04  Eclipse SDK (Patrick Schneider) 
	\item 02.02.04  Basics: ssh, cvs (mit Eclipse), Vorstellung der Berlios.de-Services 
	(cvs, ftp, xdocs) und Duckforge-Time-Managment (Oliver Rendgen)
	\item 04.02.04  Tracing (Open-Source) Projects with Maven (Tammo van Lessen) 
	\item 23.02.04  Design Patterns (Armin Cont, Michael Grosse)  
	\item 23.02.04  Eclipse SWT/GEF (Tammo van Lessen) 
	\item 25.03.04  XML-RPC Kommunikation ï¿½ber HTTPS (Anselm Garbe)  
	\item 25.03.04  Drools Regelengine (Bettina Druckenmï¿½ller)  
\end{itemize}




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Projektablauf}

\section{Prozessmodell}

Es wurde ein evolutionï¿½res Vorgehensmodell\footnote{Vgl. Literatur, u.a. J.
Ludewig, Sammlung von Kapiteln zum Software Engineering} angewendet, das sich
in mehrere Iterationen unterteilte. Jede Iteration entsprach dem
Wasserfall-Vorgehensmodell. Das Vorgehensmodell ï¿½hnelt dem Spiralmodell nach
B.W. Boehm.
Durch die Anwendung dieses Vorgehensmodells ergaben sich folgende Vorteile:

\begin{itemize}
\item Der Umfang der iterativen Spezifikationen und Entwï¿½rfe war wesentlich
kleiner als bei einer Wasserfall-Gesamtentwicklung. Der inkrementelle Umfang
resultierte in einer geringeren Fehleranfï¿½lligkeit und garantierte somit einen
hï¿½heren Qualitï¿½tsstandard.
\item Der Entwicklungsfortschritt konnte somit vom Auftraggeber und vom
Entwicklungsteam realistischer eingeschï¿½tzt werden, da regelmï¿½ï¿½ig
eine neue Auslieferung durchgefï¿½hrt wurde, die vom Auftraggeber abgenommen
werden musste.
\item Durch die Wahl der {\it J2SE} Technologie fand die Entwicklung
nach modernen {\it Design Patterns}\footnote{Vgl. Literatur, Design
Patterns, Erich Gamma} und objektorientierten Paradigmen statt. Im Gegensatz zu
imperativen Technologien wurde dadurch eine geringere Kopplung der
Software-Komponenten und somit eine bessere Zerlegung des Systems erreicht.
Eine derart leicht durchfï¿½hrbare Zerlegung des Systems nach funktionalen
Bestandteilen ermï¿½glichte besonders das evolutionï¿½re Vorgehen.
\item Es konnten neue oder geï¿½nderte Anforderungen in einer spï¿½teren Iteration
wesentlich flexibler im Entwicklunsprozess berï¿½cksichtigt und realisiert
werden.
\end{itemize}

Ein entscheidener Unterschied zu konventionellen Vorgehensmodellen war der
hï¿½here Kommunikationsaufwand zwischen dem Auftraggeber und dem Entwicklerteam.
Dieser hï¿½here Kommunikationsaufwand zeichnete sich in jedem Fall positiv fï¿½r den
Auftraggeber aus, da Anforderungen schon aufgrund der Quantitï¿½t der
Kommunikation besser einfliessen konnten. Auï¿½erdem hatte der Auftraggeber die
Mï¿½glichkeit, nach jeder abgeschlossenen Iteration, auch grï¿½ï¿½ere ï¿½nderungswï¿½nsche
einzubringen. \par


\section{Projektplan}

Bereits Wï¿½hrend des Vorprojekts wurde ein grober Plan fï¿½r das Gesamtprojekt erstellt,
der Bestandteil des Angebots wurde. Dieser grobe Projektplan wurde zu Beginn der
ersten Iteration grï¿½ndlich ï¿½berarbeitet und sehr detailiert festgelegt.\par

Da dem Kunden nach Abschluï¿½ jeder Iteartion die Mï¿½glichkeit gegeben wurde, aktiv auf
die Entwicklung Einfluï¿½ zu nehmen und dieser davon auch mit offensichtlicher
Begeisterung Gebrauch machte, wurde der ursprï¿½ngliche Projektplan zu Beginn jeder neuen
Iteration an die vom Kunden neu geschaffenen Realitï¿½ten angepasst.

\subsection{Analyse und Angebot}
Wï¿½hrend der Anforderungsanalyse wurde in mehreren Treffen die
Anforderungen des Kunden ermittelt. Die Ergebnisse wurden in einem
Angebot dokumentiert, das dem Kunden zur Abnahme vorgelegt wurde. Das
Angebot beinhaltete eine Beschreibung des geplanten Projekts.

\subsection{Spezifikation und Entwurf}
FÃÂ¼r die Erstellung der Spezifikation wurde zu Beginn der ersten Iteartion der mit Abstand
grÃ¶ÃÂŸte Aufwand getrieben. Die im Vorfeld gesammelten Anforderungen wurden dabei so umfassend
wie mÃÂ¶glich in die Spezifikation eingebunden, wobei der Kunde in Einzelfragen noch einige
Male konsultiert wurde. In den nachfolgenden Iterationen wurde die Spezfikation angepasst,
wenn dies notwendig wurde; die dadurch eingebrachten Ã„nderungen waren allerdings erwartungsgemÃ¤ÃÂŸ 
von sehr geringem Umfang.\par
Entsprechend der herausragenden Bedeutung der ersten Spezifikation, wurde diese allen zur VerfÃÂ¼gung
stehenden QualitÃÂ¤tssicherungsmaÃŸnahmen unterzogen, von regelmÃ¤ÃÂŸigen schriftlichen Statements bereits
der Vorversion, ÃÂ¼ber zwei formale Reviews, bis hin zu einem abschlieÃŸenden protokollierten Walkthrough.
Die Spezifikation wurde spÃÂ¤ter die Grundlage der ersten Abschlusstests des Kobold Systems.\par
FÃÂ¼r den Architekturentwurf wurde ein ÃÂ¤hnliches Vorgehen gewÃÂ¤hlt, das heiÃŸt der Aufwand fÃÂ¼r die Erstellung
des Entwurfs wÃÂ¤hrend der ersten Iteration war deutlich grÃ¶ÃÂŸer, als der Anpassungsaufwand in den spÃÂ¤teren
Iterationen. Als Vorbereitung wurde unmittelbar vor Beginn der Entwurfsarbeiten eine eigens dafÃÂ¼r anberaumte
Schulung zum Thema Entwurfstechniken und Design Patterns durchgefÃÂ¼hrt und bei der Erstellung des Entwurfs
wurde groÃŸer Wert auf die Verwendung diverser Entwurfsmuster gelegt, um eine mÃÂ¶glichst kopplungsfreie und
wartungsfreundliche Struktur im System zu realisieren.\par
Der Entwurf wurde in zwei groÃŸen Schritten erstellt. Ein relativ kleines Team, zu dem auch die Schulungsleiter
der oben angesprochenen Schuluung gehÃÂ¶rten, erstellte zunÃÂ¤chst einen Grobentwurf, der intensiv vom restlichen 
Team geprÃÂ¼ft und nach anschlieÃŸender Ausreifung durch die sehr detaillierte Ausgestaltung der wichtigsten Module 
und aller Schnittstellen soweit verfeinert wurde, dass er wÃÂ¤hrend der spÃÂ¤ter folgenden Implementierungsarbeiten 
mit groÃŸem Gewinn eingesetzt werden konnte.


\section{Handbuch}
Das Handbuch wurde von einem einzelnen Entwickler parallel zu den Iterationen 
erstellt und befand sich somit immer auf dem neuesten Stand. Es enthï¿½lt eine 
Beschreibung der graphischen Benutzungsoberflï¿½che und der Funktionalitï¿½t 
von Kobold und ein Tutorial. Das Handbuch wurde in einem Review geprï¿½ft und
zusammen mit Kobold ausgeliefert.


\section{Auslieferung}
Die wï¿½hrend der Prï¿½sentation ausgelieferten Ergebnisse sind in den
beiden vorhergehenden Abschnitten beschrieben. Die Auslieferung
markierte mit der Erfï¿½llung der Projektanforderungen das vorlï¿½ufige
Ende des Projekts.

\section{Nachbesserung}
Im Anschluss an die Auslieferung Ende August begann eine 3-monatige
Nachbesserungsphase. Es sollten lediglich Fehler behoben
werden, aber keine neuen Anforderungen umgesetzt werden. Nach Behebung der 
meisten Fehler wird Kobold am 26.11.2004 als endgültig ausgeliefert.


\section{Abschlussbericht und Prï¿½sentation}
Der Abschlussbericht ist das vorliegende Dokument. Die
Abschlussprï¿½sentation ist fï¿½r den 26.11.2004 geplant. Zusammen
mit einem ausgedruckten Exemplar des Abschlussberichts wird eine CD, die
sï¿½mtliche Projektergebnisse beinhaltet, ausgeliefert werden.


\section{Arbeitszeitverteilung}

\begin{figure}[h!]
  \centering
  \includegraphics[width=12.5cm]{praesentation/zeit_pro_entwickler}
  \caption{Zeitliche Aufwandsverteiung auf die Entwickler}
\end{figure}

\begin{figure}[h!]
  \centering
  \includegraphics[width=12.5cm]{praesentation/aufwand_pro_phase}
  \caption{Zeitliche Aufwandsverteilung auf die Aktivitï¿½ten}
\end{figure}


\section{Werkzeuge}

Die im Rahmen des Projekts eingesetzten Werkzeuge lassen sich grob in drei Kategorien
einteilen:\par

Als Kommunikationswerkzeuge wurden hauptsï¿½chlich verschiedene Emailsysteme und 
Mobilfunktelefone eingesetzt. Das Gros der im Rahmen des Projekts versendeten
Emails lief ï¿½ber zwei eigens fï¿½r dieses Projekt eingerichtete Verteilerlisten,
eine Team-interne und eine das Team und den Projekteigentï¿½mer umfassende.\par

Zur Erstellung von nicht-Code-Dokumenten aller Art wurde die Dokumentenerzeugungssprache
Tech eingesetzt sowie der UML-Diagrammer ArgoUML fï¿½r Entwurfsdokumente. In einigen
Ausnahmefï¿½llen wurden das Prï¿½sentationswerkzeug Powerpoint (fï¿½r einige Schulungen) sowie
diverse einfache Texteditoren eingesetzt.\par

Zur Erstellung von Codedokumenten wurden die Editoren der integrierten Java Entwicklungsumgebung 
der Eclipse-Plattform eingesetzt. Sï¿½mtliche Dokumente wurden ï¿½ber ein zentrales CVS-Repository 
verwaltet, welches vom Fraunhofer Institut ï¿½ber die Berlios-Plattform zur Verfï¿½gung gestellt wurde.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Statistische Analyse}


\section{Quellcodeumfang}

\begin{figure}[h!]
  \centering
  \includegraphics[width=15cm]{praesentation/lines_of_code}
  \caption{Quellcode Zeilenanzahl ï¿½ber die Zeit}
\end{figure}

Das Diagramm zeigt die gesammte Zeilenanzahl des Quellcodes inklusive
aller Kommentarzeilen ï¿½ber die Laufzeit des Projekts. Die vertikalen
gestrichelten Linien geben die Versionsmarkierungen an.\par

An dem Diagramm lassen sich auch die Iterationen ablesen. Dabei stehen die 
Markierungen mit der Bezeichnung PP fï¿½r einen jeweils neuen Projektplan und
somit fï¿½r eine neue Iteration. Die End-Deploy Markierungen zum Ende des Projektes
stehen fï¿½r einen weiteren ï¿½bergang in eine verkï¿½rzte Itertion, in der nur noch
implementiert und getestet wurde.\par

Es ist deutlich zu sehen, wie die Anzahl der Codezeilen nach Abschluss des ersten
Entwurfes (Markierung E 1-0) rapide zu steigen beginnt. Die drei flachen Sektoren im August, September und Oktober zeigen die
Prï¿½fungszeit, in der die Mehrzahl der Team-Mitglieder ausfiehl. 


\section{Umfang der Module}

\begin{figure}[h!]
  \centering
  \includegraphics[width=15cm]{praesentation/modulgroessen}
  \caption{Umfang der Module in Codezeilen}
\end{figure}

Dieses Diagramm zeigt Grï¿½ï¿½enverhï¿½ltnisse der Module, gemessen in
Quellcodezeilen. Dabei fï¿½llt das PLAM-Modul besonders groï¿½ aus, da sich
in diesem Modul die gesamte GUI-Implementierung befindet. Die Grï¿½ï¿½en der
VCM, Common und Server-Module spiegeln in keinem Fall den Aufwand wider.\par

Die Daten des Tests befinden sich in dem Modul "other". Allerdings ist zu
berï¿½cksichtigen, dass die meisten Testdaten dort nicht inbegriffen sind und
der automatisierte Test in den Modulen des jeweils zu testenden Teiles enthalten
sind. 


\section{Aufwand fï¿½r die einzelnen Phasen}

\begin{figure}[h!]
  \centering
  \includegraphics[width=15cm]{praesentation/aufwand_pro_phase}
  \caption{Aufwand pro Phase gemessen in Arbeitszeit}
\end{figure}

Das Diagramm zeigt den prozentuellen Anteil der Arbeitszeit, der fï¿½r die einzelnen
Phasen aufgebracht wurde. Besonders auffï¿½llig ist der groï¿½e Anteil der Implementierung
mit ï¿½ber 60 Prozent. Im Vergleich dazu sind die Phasen Spezifikation und Entwurf 
sehr kurz gehalten. Mï¿½glicherweise ist deshalb der Aufwand fï¿½r die Implementierung 
so groï¿½ ausgefallen. Aufgrund dessen ist bedauerlicherweise auch der Anteil am 
Test relativ gering. Dies liegt mitunter daran, dass erst spï¿½t mit dem offiziellen Test
begonnen wurde und grï¿½ï¿½ere Fehler im Programm oft einen Test vorzeitig beendeten.


\section{Entwicklerkooperation}
\label{developer by file}

\begin{figure}[h!]
  \centering
  \begin {tabular}[l]{ll}
    \hline
    Dateiname & Entwickleranzahl \\
    \hline
    src/kobold.server/src/kobold/server/SecureKoboldWebServer.java  & 7 \\
    src/kobold.common/src/kobold/common/data/Product.java  & 7 \\
    src/kobold.client.plam/src/kobold/client/plam/editor/dialog/AssetConfigurationDialog.java & 7 \\
    src/kobold.client.plam/plugin.xml & 7 \\
    src/kobold.common/src/kobold/common/data/WorkflowMessage.java & 6 \\
    src/kobold.common/src/kobold/common/data/Productline.java & 6 \\
    src/kobold.client.vcm/src/kobold/client/vcm/preferences/VCMPreferencePage.java  & 6 \\
    src/kobold.client.vcm/src/kobold/client/vcm/communication/ScriptServerConnection.java & 6 \\
    src/kobold.client.plam/src/kobold/client/plam/model/productline/Variant.java & 6 \\
    src/kobold.client.plam/src/kobold/client/plam/model/productline/Productline.java & 6 \\
    \hline
  \end {tabular}
  \caption{Anzahl Entwickler pro Datei (Top 10)}
\end{figure}

Diese Tabelle zeigt zu einer Liste von Quellcode-Dateien die Anzahl
von Entwicklern, die jeweils gemeinsam an einer Datei gearbeitet haben.
Es sind nur die Top zehn Dateien angegeben, aber auch in einer Liste
aller Dateien wï¿½rden sich nie weniger als zwei Bearbeiter pro Datei
finden lassen. 

Es gab innerhalb des Teams fï¿½r die Implementierung eines Moduls
jeweils einen bekannten zustï¿½ndigen Entwickler, der im besonderen mit
dem Quellcode vertraut war. Mit diesem wurde vor grï¿½sseren ï¿½nderungen
innerhalb seines Zustï¿½ndigkeitsbereichs durch andere Entwickler
Rï¿½cksprache gehalten, so daï¿½ Konflikte im vorraus vermieden werden
konnten. Kleinere ï¿½nderungen oder Fehlerkorrekturen konnten im
Zweifelsfall auch nachtrï¿½glich oder ï¿½ber das Quellcode Repository
kommuniziert werden.

Diese Form des ``Collective Code Ownership'' ist sehr positiv zu
bewerten. Es hat Reibungsverluste bei ï¿½nderungen und die Entstehung
von Quellcode, der nur von einem einzelnen Entwickler verstanden und
gewartet werden kann, vermieden. Alleine durch die Kenntniss, daï¿½
Quellcode von anderen gelesen wird, konnte die Lesbarkeit und Qualitï¿½t
erhï¿½ht werden.



\section{Arbeitzeit}

\begin{figure}[h!]
  \centering
  \includegraphics[width=15cm]{praesentation/commit_by_hour}
  \caption{Uhrzeiten der CVS Repository Aktivitï¿½t}
\end{figure}

Das Diagramm zeigt die Uhrzeiten der Aktivitï¿½ten im Quellcode
Repository. Eine hï¿½here Anzahl Commits bedeutet eine hï¿½here
Aktivitï¿½t. Typisch ist die erhï¿½hte Aktivitï¿½t zwischen 13 und 19 Uhr,
die auch bei anderen Studienprojekten zu beobachten
ist. Offensichtlich ist das eine ï¿½bliche Zeit das Arbeitsergebnis z.B.
zum Ende der Kernarbeitszeit in das Repository zu
comitten. Bemerkenswert sind die Aktivitï¿½ten nach 22 Uhr, die bis in
die Morgenstunden reichen. Es gibt eine ausgeprï¿½gte
Bandbreite von bevorzugten Arbeitszeiten wobei die Arbeiter am Nachmittag
eindeutig die Mehrheit im Team stellen. 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Persï¿½nliche Berichte}

%TODO! -> alle!


\include{cont.tex}

\include{grosse.tex}

\include{rendgen.tex}

\appendix

\chapter{Erklï¿½rung gemï¿½ï¿½ Prï¿½fungsordnung}

Ich erklï¿½re hiermit, dass ich im Rahmen meiner Mitarbeit am
Studienprojekt A ``Produktlinien'' auï¿½er von den
Betreuern vorgesehenen bzw. genehmigten Hilfsmitteln keine unzulï¿½ssige
Hilfe in Anspruch genommen habe.

\vspace{2cm}
Stuttgart, den 25. Oktober 2004
\vspace{2cm}

\begin{center}
\begin{tabular}{ccc}
  \hspace{5cm} & \hspace{5cm} & \hspace{5cm} \\
  \hhline{-~-} Necati Aydin & & Anselm Garbe \\
  \vspace{1,5cm} \\
  \hhline{-~-} Michael Grosse & & Martin Plies \\
  \vspace{1,5cm} \\
  \hhline{-~-} Oliver Rendgen & & Patrick Schneider \\
    \vspace{1,5cm} \\
  \hhline{-~-} Armin Cont & & Bettina Druckenmï¿½ller \\
  \vspace{1,5cm} \\
  \hhline{-~~} Tammo van Lessen \\
\end{tabular}
\end{center}

\end{document}
